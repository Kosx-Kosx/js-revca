;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Array2d, BaseMouseTool, BufferPane, ButtonGroup, Cells, DelayedHandler, DomBuilder, E, FieldView, GhostClickDetector, GolApplication, LibraryPane, MargolusNeighborehoodField, NamedRules, Point, Rule2Name, Rules, SpaceshipCatcher, ToolDraw, ToolEraser, ToolSelect, ToolStamp, Transforms, addClass, addDelayedListener, cap, div, drawPatternOnCanvas, fill_rules, getCanvasCursorPosition, getDualTransform, getReadableFileSizeString, idOrNull, line_pixels, loadExternalCSS, makeElement, mod, nodefault, parseUri, parse_rle, rational2str, removeClass, remove_whitespaces, selectOption, selectOrAddOption, selectValue2Option, show_rule_diagram, show_rule_properties, spaceshipType, splitPattern, _ref, _ref1, _ref2, _ref3, _ref4,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require("./rules"), Rules = _ref.Rules, NamedRules = _ref.NamedRules, Rule2Name = _ref.Rule2Name;

_ref1 = require("./cells"), Cells = _ref1.Cells, Point = _ref1.Point, splitPattern = _ref1.splitPattern, getDualTransform = _ref1.getDualTransform;

_ref2 = require("./reversible_ca"), MargolusNeighborehoodField = _ref2.MargolusNeighborehoodField, Array2d = _ref2.Array2d;

_ref3 = require("./math_util"), div = _ref3.div, mod = _ref3.mod, line_pixels = _ref3.line_pixels, rational2str = _ref3.rational2str, getReadableFileSizeString = _ref3.getReadableFileSizeString, cap = _ref3.cap;

FieldView = require("./field_view").FieldView;

getCanvasCursorPosition = require("./canvas_util").getCanvasCursorPosition;

DomBuilder = require("./dom_builder").DomBuilder;

parseUri = require("./parseuri").parseUri;

_ref4 = require("./rle"), parse_rle = _ref4.parse_rle, remove_whitespaces = _ref4.remove_whitespaces;

E = function(id) {
  return document.getElementById(id);
};

nodefault = function(handler) {
  return function(e) {
    e.preventDefault();
    return handler(e);
  };
};

makeElement = function(tag, attrs, text) {
  var attr, aval, elem, _i, _len, _ref5;
  elem = document.createElement(tag);
  if (attrs != null) {
    for (_i = 0, _len = attrs.length; _i < _len; _i++) {
      _ref5 = attrs[_i], attr = _ref5[0], aval = _ref5[1];
      elem.setAttribute(attr, aval);
    }
  }
  if (text != null) {
    elem.appendChild(document.createTextNode(text));
  }
  return elem;
};

removeClass = function(e, c) {
  var ci, classes, _i, _len, _ref5;
  classes = [];
  _ref5 = e.className.split(" ");
  for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
    ci = _ref5[_i];
    if (c !== ci) {
      classes.push(ci);
    }
  }
  e.className = classes.join(" ");
  return null;
};

addClass = function(e, c) {
  var classes;
  classes = e.className;
  e.className = (classes = e.className) === "" ? c : classes + " " + c;
  return null;
};

selectValue2Option = function(elem) {
  var opt, val2opt, _i, _len, _ref5;
  val2opt = {};
  _ref5 = elem.options;
  for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
    opt = _ref5[_i];
    val2opt[opt.value] = opt;
  }
  return val2opt;
};

selectOption = function(elem, value, value0) {
  var o, val2opt;
  val2opt = selectValue2Option(elem);
  o = val2opt[value];
  if (value0 && (o == null)) {
    o = val2opt[value0];
  }
  if (o != null) {
    return o.selected = true;
  }
};

selectOrAddOption = function(elem, value, nameToAdd) {
  var option, val2opt;
  if (nameToAdd == null) {
    nameToAdd = value;
  }
  val2opt = selectValue2Option(elem);
  if ((option = val2opt[value]) == null) {
    option = new Option(nameToAdd, value);
    elem.options[elem.options.length] = option;
  }
  return option.selected = true;
};

idOrNull = function(elem) {
  if (elem === null) {
    return null;
  } else {
    return elem.getAttribute("id");
  }
};

spaceshipType = function(dx, dy) {
  if (dx == null) {
    return "unknown";
  } else if (dx === 0 && dy === 0) {
    return "oscillator";
  } else if (dx === 0 || dy === 0) {
    return "orthogonal spaceship";
  } else if (Math.abs(dx) === Math.abs(dy)) {
    return "diagonal spaceship";
  } else {
    return "slant spaceship";
  }
};

ButtonGroup = (function() {
  function ButtonGroup(containerElem, tag, selectedId, selectedClass) {
    var btn, _i, _len, _ref5;
    if (selectedId == null) {
      selectedId = null;
    }
    this.selectedClass = selectedClass != null ? selectedClass : "btn-selected";
    if (selectedId !== null) {
      addClass((this.selected = E(selectedId)), this.selectedClass);
    } else {
      this.selected = null;
    }
    this.handlers = {
      change: []
    };
    _ref5 = containerElem.getElementsByTagName(tag);
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      btn = _ref5[_i];
      btn.addEventListener("click", this._btnClickListener(btn));
    }
    null;
  }

  ButtonGroup.prototype._btnClickListener = function(newBtn) {
    var _this = this;
    return function(e) {
      var handler, newId, oldBtn, oldId, _i, _len, _ref5;
      oldBtn = _this.selected;
      newId = idOrNull(newBtn);
      oldId = idOrNull(oldBtn);
      if (newId !== oldId) {
        if (oldBtn !== null) {
          removeClass(oldBtn, _this.selectedClass);
        }
        if (newBtn !== null) {
          addClass(newBtn, _this.selectedClass);
        }
        _this.selected = newBtn;
        _ref5 = _this.handlers.change;
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          handler = _ref5[_i];
          handler(e, newId, oldId);
        }
        return null;
      }
    };
  };

  ButtonGroup.prototype.addEventListener = function(name, handler) {
    var handlers;
    if ((handlers = this.handlers[name]) == null) {
      throw new Error("Hander " + name + " is not supported");
    }
    return handlers.push(handler);
  };

  return ButtonGroup;

})();

DelayedHandler = (function() {
  function DelayedHandler(delayMs, handler) {
    this.delayMs = delayMs;
    this.handler = handler;
    this.timerId = null;
  }

  DelayedHandler.prototype.fireEvent = function(e) {
    var _this = this;
    this.cancel();
    return this.timerId = setTimeout((function() {
      return _this.handler(e);
    }), this.delayMs);
  };

  DelayedHandler.prototype.cancel = function() {
    var t;
    if ((t = this.timerId) !== null) {
      clearTimeout(t);
      return this.timerId = null;
    }
  };

  return DelayedHandler;

})();

addDelayedListener = function(element, eventNames, delayMs, listener) {
  var delayedListener, eName, handler, _i, _len;
  delayedListener = new DelayedHandler(delayMs, listener);
  handler = function(e) {
    return delayedListener.fireEvent(e);
  };
  for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
    eName = eventNames[_i];
    element.addEventListener(eName, handler);
  }
  return null;
};

GolApplication = (function() {
  function GolApplication(field_size, rule_string, container_id, canvas_id, overlay_id, time_display_id) {
    var rule;
    rule = Rules.parse(rule_string);
    this.gol = new MargolusNeighborehoodField((function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(Array2d, field_size, function(){}), rule);
    this.gol.clear();
    this.view = new FieldView(this.gol.field);
    this.step_size = 1;
    this.step_delay = 50;
    this.field_player = null;
    this.field_player_proc = null;
    this.canvas = E(canvas_id);
    this.canvas_overlay = E(overlay_id);
    this.canvas_container = E(container_id);
    this.time_display = time_display_id && E(time_display_id);
    this.mouse_tools = {
      draw: new ToolDraw(this),
      select: new ToolSelect(this),
      stamp: new ToolStamp(this),
      eraser: new ToolEraser(this, 5)
    };
    this.mouse_tool = null;
    this.selection = null;
    this.encoder = null;
    this.spaceship_catcher = null;
    this.library = new LibraryPane(E("pattern-report"), E("library-size"), this);
    this.buffer = new BufferPane(E("active-pattern-canvas"));
    this.ghost_click_detector = new GhostClickDetector();
  }

  GolApplication.prototype.setSize = function(cols, rows) {
    var RECOMMENDED_HEIGHT, RECOMMENDED_WIDTH, ctx, max_cell_size;
    RECOMMENDED_WIDTH = 800;
    RECOMMENDED_HEIGHT = 600;
    if (!(cols === this.gol.field.width && rows === this.gol.field.height)) {
      this.gol = new MargolusNeighborehoodField(new Array2d(cols, rows), this.gol.rule);
      this.gol.clear();
      this.view.field = this.gol.field;
      max_cell_size = Math.min(RECOMMENDED_WIDTH / cols, RECOMMENDED_HEIGHT / rows) | 0;
      if (max_cell_size < this.view.cell_size) {
        this.view.cell_size = max_cell_size;
        if (max_cell_size <= 2) {
          this.view.grid_width = 0;
        }
      }
      this.adjustCanvasSize();
      ctx = this.canvas.getContext("2d");
      this.view.invalidate();
      return this.view.draw(ctx);
    }
  };

  GolApplication.prototype.startPlayer = function(direction) {
    if (this.field_player) {
      this.stopPlayer();
    }
    this.field_player_proc = (function() {
      var _this = this;
      switch (direction) {
        case 1:
          return function() {
            return _this.doStep();
          };
        case -1:
          return function() {
            return _this.doReverseStep();
          };
        default:
          throw new Error("Bad direction:" + direction);
      }
    }).call(this);
    return this.field_player = window.setInterval(this.field_player_proc, this.step_delay);
  };

  GolApplication.prototype.isPlaying = function() {
    return this.field_player != null;
  };

  GolApplication.prototype.stopPlayer = function() {
    if (this.field_player) {
      window.clearInterval(this.field_player);
      return this.field_player = null;
    }
  };

  GolApplication.prototype.updateCanvas = function() {
    return this.view.draw(this.canvas.getContext("2d"));
  };

  GolApplication.prototype.updateCanvasBox = function(x0, y0, x1, y1) {
    return this.view.draw_box(this.canvas.getContext("2d"), x0, y0, x1, y1);
  };

  GolApplication.prototype.parseCellSize = function(sel_style) {
    var sh, st, sw, _ref5;
    _ref5 = st = sel_style.split(","), sw = _ref5[0], sh = _ref5[1];
    if (st.length !== 2) {
      throw new Error("Value is incorrect: " + sel_style);
    }
    return [parseInt(sw, 10), parseInt(sh, 10)];
  };

  GolApplication.prototype.adjustCanvasSize = function() {
    var h, w;
    w = this.gol.field.width * this.view.cell_size;
    h = this.gol.field.height * this.view.cell_size;
    this.canvas_container.style.width = "" + w + "px";
    this.canvas_container.style.height = "" + h + "px";
    this.canvas_overlay.width = this.canvas.width = w;
    return this.canvas_overlay.height = this.canvas.height = h;
  };

  GolApplication.prototype.setCellSize = function(size) {
    var ctx;
    this.view.cell_size = size;
    this.adjustCanvasSize();
    ctx = this.canvas.getContext("2d");
    this.view.invalidate();
    return this.view.draw(ctx);
  };

  GolApplication.prototype.setShowGrid = function(show) {
    var ctx;
    this.view.grid_width = show ? 1 : 0;
    ctx = this.canvas.getContext("2d");
    this.view.invalidate();
    return this.view.draw(ctx);
  };

  GolApplication.prototype.doStep = function() {
    var gc, i, _i, _ref5;
    for (i = _i = 0, _ref5 = this.step_size; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
      this.gol.transform();
      if ((this.gol.phase === 0) && (gc = this.spaceship_catcher)) {
        gc.scan(this.gol);
      }
    }
    if ((this.spaceship_catcher != null) && this.gol.generation >= this.spaceship_catcher.reseed_period) {
      this.do_clear();
      this.random_fill_selection(parseFloat(E("random-fill-percent").value) * 0.01);
    }
    this.updateCanvas();
    this.update_time();
    return this.recordFrame();
  };

  GolApplication.prototype.recordFrame = function() {
    var sizeElem;
    if (this.encoder == null) {
      return;
    }
    this.encoder.addFrame(this.canvas.getContext("2d"));
    sizeElem = document.getElementById("gif-size");
    if (sizeElem != null) {
      return sizeElem.innerHTML = getReadableFileSizeString(this.encoder.stream().getSize());
    }
  };

  GolApplication.prototype.setMouseTool = function(tool) {
    if (this.mouse_tool) {
      this.mouse_tool.on_disable();
    }
    this.mouse_tool = tool;
    if (tool) {
      return tool.on_enable();
    }
  };

  GolApplication.prototype.setDelay = function(delay) {
    if ((delay != null) && delay <= 0) {
      throw new Error("Bad delay value: " + delay);
    }
    if (delay === this.step_delay) {
      return;
    }
    this.step_delay = delay;
    if (this.isPlaying()) {
      window.clearInterval(this.field_player);
      return this.field_player = window.setInterval(this.field_player_proc, this.step_delay);
    }
  };

  GolApplication.prototype.doReverseStep = function() {
    var e, i, _i, _ref5;
    try {
      for (i = _i = 0, _ref5 = this.step_size; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
        this.gol.untransform();
      }
      this.updateCanvas();
      this.update_time();
      return this.recordFrame();
    } catch (_error) {
      e = _error;
      alert("" + e);
      return this.stopPlayer();
    }
  };

  GolApplication.prototype.update_time = function() {
    if (this.time_display) {
      return this.time_display.innerHTML = "" + this.gol.generation;
    }
  };

  GolApplication.prototype.reset_time = function() {
    this.gol.set_generation(mod(this.gol.generation, 2));
    return this.update_time();
  };

  GolApplication.prototype.set_rule = function(srule) {
    var e, rule;
    try {
      rule = Rules.parse(srule);
      this.gol.set_rule(rule);
      show_rule_diagram(rule, E("function_display"));
      return show_rule_properties(rule, E("function_properties"));
    } catch (_error) {
      e = _error;
      return alert("" + e);
    }
  };

  GolApplication.prototype.do_clear = function() {
    this.gol.clear();
    this.updateCanvas();
    return this.update_time();
  };

  GolApplication.prototype.attach_listeners = function() {
    var self, widget;
    widget = this.canvas_container;
    self = this;
    widget.addEventListener("mousedown", nodefault((function(e) {
      if (!self.ghost_click_detector.isGhost) {
        return self.mouse_tool.on_mouse_down(e);
      }
    }), false));
    widget.addEventListener("mouseup", nodefault(function(e) {
      if (!self.ghost_click_detector.isGhost) {
        return self.mouse_tool.on_mouse_up(e);
      }
    }), false);
    widget.addEventListener("mousemove", nodefault(function(e) {
      return self.mouse_tool.on_mouse_move(e);
    }), false);
    widget.addEventListener("mouseout", nodefault(function(e) {
      return self.mouse_tool.on_mouse_out(e);
    }), false);
    widget.addEventListener("touchstart", (function(e) {
      return self.mouse_tool.on_touch_start(e);
    }), false);
    widget.addEventListener("touchend", (function(e) {
      return self.mouse_tool.on_touch_end(e);
    }), false);
    widget.addEventListener("touchmove", (function(e) {
      return self.mouse_tool.on_touch_move(e);
    }), false);
    widget.addEventListener("touchleave", (function(e) {
      return self.mouse_tool.on_touch_leave(e);
    }), false);
    return this.ghost_click_detector.addListeners(widget);
  };

  /*
  Load initial state from the URL parameters
  */


  GolApplication.prototype.load_parameters = function() {
    var c, colors, e, keys, r, s, sz, x0, y0, _ref5, _ref6,
      _this = this;
    keys = parseUri(window.location).queryKey;
    if (keys.size != null) {
      sz = keys.size.split('x');
      if (sz.length !== 2) {
        throw new Error("Size must have form WIDTHxHEIGHT");
      }
      c = parseInt(sz[0], 10);
      r = parseInt(sz[1], 10);
      if (r % 2 !== 0 || c % 2 !== 0) {
        throw new Error("Width and height must be even");
      }
      this.gol = new MargolusNeighborehoodField(new Array2d(c, r), this.gol.rule);
      this.gol.clear();
      this.view = new FieldView(this.gol.field);
    }
    if (keys.cell_size != null) {
      _ref5 = this.parseCellSize(keys.cell_size), this.view.cell_size = _ref5[0], this.view.grid_width = _ref5[1];
    }
    if (keys.colors != null) {
      colors = keys.colors.split(";");
      if (colors.length !== 4) {
        throw new Error("Colors attribute must have 4 ';'-separated values: colors of cells and colors of grid");
      }
      this.view.cell_colors[0] = colors[0];
      this.view.cell_colors[1] = colors[1];
      this.view.grid_colors[0] = colors[2];
      this.view.grid_colors[1] = colors[3];
    }
    if (keys.rle != null) {
      x0 = keys.rle_x0 ? parseInt(keys.rle_x0, 10) : 0;
      y0 = keys.rle_y0 ? parseInt(keys.rle_y0, 10) : 0;
      parse_rle(keys.rle, function(x, y) {
        return _this.gol.field.set_wrapped(x0 + x, y0 + y, 1);
      });
    }
    if (keys.rule != null) {
      try {
        r = (_ref6 = NamedRules[keys.rule]) != null ? _ref6 : Rules.parse(keys.rule, ",");
        this.gol.set_rule(r);
      } catch (_error) {
        e = _error;
        alert("Incorrect rule: " + keys.rule);
      }
    }
    if (keys.frame_delay != null) {
      try {
        this.setDelay(parseInt(keys.frame_delay, 10));
      } catch (_error) {
        e = _error;
        alert(e);
      }
    }
    if (keys.step != null) {
      try {
        s = parseInt(keys.step, 10);
        if ((s == null) || s <= 0) {
          throw new Error("Incorrect step value:" + s);
        }
        return this.step_size = s;
      } catch (_error) {
        e = _error;
        return alert(e);
      }
    }
  };

  GolApplication.prototype.encode_state_in_url = function() {
    var argsStartAt, baseUrl, fld, loc, pattern, srle, srule, urlArgs, x0, y0, _ref5;
    urlArgs = [];
    srule = Rules.stringify(this.gol.rule);
    urlArgs.push("rule=" + srule);
    fld = this.gol.field;
    pattern = fld.get_cells(0, 0, fld.width, fld.height);
    if (pattern.length > 0) {
      _ref5 = Cells.bounds(pattern), x0 = _ref5[0], y0 = _ref5[1];
      srle = Cells.to_rle(Cells.offset(pattern, -x0, -y0));
      urlArgs.push("rle_x0=" + x0);
      urlArgs.push("rle_y0=" + y0);
      urlArgs.push("rle=" + srle);
    }
    urlArgs.push("step=" + this.step_size);
    urlArgs.push("frame_delay=" + this.step_delay);
    urlArgs.push("size=" + fld.width + "x" + fld.height);
    urlArgs.push("cell_size=" + this.view.cell_size + "," + this.view.grid_width);
    loc = "" + window.location;
    argsStartAt = loc.indexOf("?");
    baseUrl = argsStartAt === -1 ? loc : loc.substr(0, argsStartAt);
    return baseUrl + "?" + (urlArgs.join("&"));
  };

  GolApplication.prototype.initialize = function() {
    this.load_parameters();
    this.adjustCanvasSize();
    this.setMouseTool(this.mouse_tools.draw);
    this.updateCanvas();
    return this.attach_listeners();
  };

  GolApplication.prototype.clear_selection = function() {
    var sel;
    if (sel = this.selection) {
      this.gol.field.fill_box(sel[0], sel[1], sel[2], sel[3], 0);
      return this.updateCanvasBox.apply(this, sel);
    }
  };

  GolApplication.prototype.random_fill_selection = function(p) {
    var sel;
    if (p < 0 || p > 1 || isNaN(p)) {
      alert("Wrong percentage: " + p);
      return;
    }
    if (sel = this.selection) {
      this.gol.field.random_fill(sel[0], sel[1], sel[2] + 1, sel[3] + 1, p);
      return this.updateCanvasBox.apply(this, sel);
    }
  };

  GolApplication.prototype._getAnalyzerMaxSteps = function() {
    var maxSteps;
    maxSteps = parseInt(E("analysis-max-steps").value, 10);
    if (isNaN(maxSteps)) {
      maxSteps = 2048;
      alert("Incorrect value of the analysis depth, will use " + maxSteps);
    }
    return maxSteps;
  };

  GolApplication.prototype.enable_spaceship_catcher = function() {
    var e, maxSteps, max_spaceship_sz, on_spaceship, reseed_period,
      _this = this;
    if (this.spaceship_catcher === null) {
      maxSteps = this._getAnalyzerMaxSteps();
      on_spaceship = function(pattern, rule) {
        var result;
        if (result = Cells.analyze(pattern, rule, maxSteps)) {
          if (result.period != null) {
            if (result.dx !== 0 || result.dy !== 0) {
              _this.library.put(result);
            }
          }
        }
        return null;
      };
      try {
        reseed_period = parseInt(E("catcher-reseed-period").value, 10);
        max_spaceship_sz = parseInt(E("catcher-max-spaceship-size").value, 10);
        if (isNaN(reseed_period || reseed_period <= 0)) {
          throw new Error("Reseed period negative");
        }
        if ((max_spaceship_sz == null) || (isNaN(max_spaceship_sz))) {
          throw new Error("Bad max spaceship value");
        }
        this.spaceship_catcher = new SpaceshipCatcher(on_spaceship, max_spaceship_sz, reseed_period);
        E("catcher-reseed-period").readOnly = true;
        E("catcher-max-spaceship-size").readOnly = true;
        return addClass(E("toggle-catcher"), "btn-selected");
      } catch (_error) {
        e = _error;
        return alert("Failed to enable catcher:" + e);
      }
    }
  };

  GolApplication.prototype.disable_spaceship_catcher = function() {
    if (this.spaceship_catcher !== null) {
      this.spaceship_catcher = null;
      E("catcher-reseed-period").readOnly = false;
      E("catcher-max-spaceship-size").readOnly = false;
      return removeClass(E("toggle-catcher"), "btn-selected");
    }
  };

  GolApplication.prototype.clear_nonselection = function() {
    var sel;
    if (sel = this.selection) {
      this.gol.field.fill_outside_box(sel[0], sel[1], sel[2], sel[3], 0);
      return this.updateCanvas();
    }
  };

  GolApplication.prototype.start_gif_recorder = function() {
    var encoder;
    if (this.encoder) {
      return;
    }
    this.encoder = encoder = new GIFEncoder();
    encoder.setPalette(exactPalette);
    encoder.setRepeat(0);
    encoder.setDelay(this.step_delay);
    encoder.start();
    return this.recordFrame();
  };

  /*
  Stop recorder and show window or return data URL
  */


  GolApplication.prototype.stopGifRecorder = function() {
    var data_url, encoder, out;
    if (!this.encoder) {
      alert("Not started");
      return;
    }
    encoder = this.encoder;
    this.encoder = null;
    encoder.finish();
    data_url = "data:image/gif;base64," + encoder.stream().getB64Data();
    out = E("gif-output");
    out.innerHTML = "";
    return out.appendChild(makeElement("img", [["src", data_url], ["alt", "GIF animation"]]));
  };

  GolApplication.prototype.gifRecorderClear = function() {
    return E("gif-output").innerHTML = "";
  };

  GolApplication.prototype.analyzeSelection = function() {
    var cells, root,
      _this = this;
    cells = this.getSelectedCells();
    if (cells.length === 0) {
      return;
    }
    root = E("analysis-report-area");
    root.innerHTML = "<div style='text-align:center'><span class='icon-wait'>Analysing...</span></div>";
    E("analysis-result").style.display = "block";
    return window.setTimeout((function() {
      var canv, dom, in_library, makeCanvas, result, _ref5, _ref6;
      _this.analysis_result = result = Cells.analyze(cells, _this.gol.rule, _this._getAnalyzerMaxSteps());
      makeCanvas = function(imgW, imgH) {
        return makeElement("canvas", [["width", imgW], ["height", imgH]]);
      };
      canv = drawPatternOnCanvas(makeCanvas, result.cells, [128, 96], [1, 24], 1);
      in_library = (_this.library.has(result)) || (_this.library.hasDual(result, _this.gol.rule));
      dom = new DomBuilder;
      dom.tag("div").CLASS("pattern-background").append(canv).end();
      dom.tag("ul");
      dom.tag("li").text("Pattern type: ").text(spaceshipType(result.dx, result.dy)).end();
      dom.tag("li").text("Population: " + cells.length + " cells").end();
      dom.tag("li").text("Period: ").text((_ref5 = result.period) != null ? _ref5 : "unknown").end();
      if ((result.dx != null) && (result.dx || result.dy)) {
        dom.tag("li").text("Δx=" + result.dx + ", Δy=" + result.dy).end();
      }
      dom.tag("li").text(in_library ? "Present in library" : "Not in library").end();
      dom.end();
      root.innerHTML = "";
      root.appendChild(dom.finalize());
      _this.buffer.set((_ref6 = result.cells) != null ? _ref6 : cells);
      return E("analysis-result-close").focus();
    }), 1);
  };

  GolApplication.prototype.analysisResultToLibrary = function() {
    if (this.analysis_result != null) {
      return this.library.put(this.analysis_result);
    }
  };

  GolApplication.prototype.copyToBuffer = function() {
    this.analysis_result = null;
    return this.buffer.set(Cells.normalize(this.getSelectedCells()));
  };

  GolApplication.prototype.getSelectedCells = function() {
    var sel, _ref5;
    sel = this.selection;
    if (!sel) {
      return [];
    }
    sel = this.gol.snap_box(sel);
    return (_ref5 = this.gol.field).get_cells.apply(_ref5, sel);
  };

  GolApplication.prototype.saveLibrary = typeof Storage === "undefined" || Storage === null ? function() {
    return alert("Storage not supported");
  } : function(newName) {
    var e;
    if (newName == null) {
      newName = false;
    }
    try {
      this.library.save(localStorage, newName);
      return this.updateLibrariesList();
    } catch (_error) {
      e = _error;
      return alert(e);
    }
  };

  GolApplication.prototype.deleteCurrentLibrary = typeof Storage === "undefined" || Storage === null ? function() {
    return alert("Storage not supported");
  } : function() {
    if (confirm("Are you sure you want to clear current library and remove it from the local storage?\nThis action can not be undone.")) {
      this.library.deleteCurrent(localStorage);
      return this.updateLibrariesList();
    }
  };

  GolApplication.prototype.updateLibrariesList = function() {
    var key, libName, libs, libsElem, _i, _len;
    if (typeof Storage === "undefined" || Storage === null) {
      return;
    }
    libsElem = E("list-libraries");
    libs = [];
    for (key in localStorage) {
      if (key.match(/^library-/)) {
        libs.push(key.substr(8));
      }
    }
    libs.sort();
    libsElem.innerHTML = "";
    libsElem.options.add(new Option("---", ""));
    for (_i = 0, _len = libs.length; _i < _len; _i++) {
      libName = libs[_i];
      libsElem.options.add(new Option(libName, libName));
    }
    return libsElem.options[0].selected = true;
  };

  GolApplication.prototype.showOverlay = function(visible) {
    return this.canvas_overlay.style.visibility = visible ? "visible" : "hidden";
  };

  return GolApplication;

})();

BaseMouseTool = (function() {
  function BaseMouseTool(golApp, snapping, show_overlay) {
    this.golApp = golApp;
    this.snapping = snapping != null ? snapping : false;
    this.show_overlay = show_overlay != null ? show_overlay : true;
    this.dragging = false;
    this.last_xy = null;
    this.old_rect = null;
  }

  BaseMouseTool.prototype.get_xy = function(e, snap) {
    var ixy, x, y, _ref5;
    if (snap == null) {
      snap = false;
    }
    _ref5 = getCanvasCursorPosition(e, this.golApp.canvas_container), x = _ref5[0], y = _ref5[1];
    ixy = this.golApp.view.xy2index(x, y);
    if (snap) {
      return this.snap_below(ixy);
    } else {
      return ixy;
    }
  };

  BaseMouseTool.prototype.clear_old_rect = function(ctx) {
    var r;
    if ((r = this.old_rect)) {
      return ctx.clearRect.apply(ctx, r);
    }
  };

  BaseMouseTool.prototype.snap_below = function(_arg) {
    var gol, x, y;
    x = _arg[0], y = _arg[1];
    gol = this.golApp.gol;
    return [gol.snap_below(x), gol.snap_below(y)];
  };

  BaseMouseTool.prototype.on_mouse_up = function(e) {
    return this.dragging = false;
  };

  BaseMouseTool.prototype.on_mouse_move = function(e) {
    var xy, xy0;
    xy = this.get_xy(e, this.snapping);
    xy0 = this.last_xy;
    if (xy0 === null) {
      return this.last_xy = xy;
    } else {
      if (!Point.equal(xy, xy0)) {
        this.on_cell_change(e, xy);
        return this.last_xy = xy;
      }
    }
  };

  BaseMouseTool.prototype.getOverlayContext = function() {
    return this.golApp.canvas_overlay.getContext("2d");
  };

  BaseMouseTool.prototype.on_mouse_down = function(e) {
    var xy;
    this.dragging = true;
    this.last_xy = xy = this.get_xy(e, this.snapping);
    return this.on_click_cell(e, xy);
  };

  BaseMouseTool.prototype.on_enable = function() {
    this.dragging = false;
    this.last_xy = null;
    if (this.show_overlay) {
      return this.golApp.showOverlay(true);
    }
  };

  BaseMouseTool.prototype.on_disable = function() {
    if (this.show_overlay) {
      this.clear_old_rect(this.getOverlayContext());
      return this.golApp.showOverlay(false);
    }
  };

  BaseMouseTool.prototype.on_cell_change = function() {};

  BaseMouseTool.prototype.on_click_cell = function() {};

  BaseMouseTool.prototype.on_mouse_out = function() {};

  BaseMouseTool.prototype.on_touch_start = function(e) {
    if (e.touches.length === 1) {
      this.on_mouse_down(e);
      return e.preventDefault();
    }
  };

  BaseMouseTool.prototype.on_touch_leave = function(e) {
    return this.on_mouse_out(e);
  };

  BaseMouseTool.prototype.on_touch_end = function(e) {
    if (this.dragging) {
      e.preventDefault();
      return this.on_mouse_up(e);
    }
  };

  BaseMouseTool.prototype.on_touch_move = function(e) {
    if (this.dragging) {
      e.preventDefault();
      return this.on_mouse_move(e);
    }
  };

  return BaseMouseTool;

})();

/*
# In some mobile browsers, ghost clicks can not be prevented. So here easy solution: every mouse event,
# coming after some interval after a touch event is ghost
*/


GhostClickDetector = (function() {
  function GhostClickDetector() {
    var _this = this;
    this.isGhost = false;
    this.timerHandle = null;
    this.ghostInterval = 1000;
    this._onTimer = function() {
      _this.isGhost = false;
      return _this.timerHandle = null;
    };
    this._onTouch = function() {
      return _this.onTouch();
    };
  }

  GhostClickDetector.prototype.onTouch = function() {
    this.stopTimer();
    this.isGhost = true;
    return this.timerHandle = window.setTimeout(this._onTimer, this.ghostInterval);
  };

  GhostClickDetector.prototype.stopTimer = function() {
    var handle;
    if ((handle = this.timerHandle)) {
      window.clearTimeout(handle);
      return this.timerHandle = null;
    }
  };

  GhostClickDetector.prototype.addListeners = function(element) {
    var evtName, _i, _len, _ref5, _results;
    _ref5 = ["touchstart", "touchend"];
    _results = [];
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      evtName = _ref5[_i];
      _results.push(element.addEventListener(evtName, this._onTouch, false));
    }
    return _results;
  };

  return GhostClickDetector;

})();

/*
# Mouse tool for erasing
*/


ToolEraser = (function(_super) {
  __extends(ToolEraser, _super);

  function ToolEraser(golApp, size) {
    this.size = size != null ? size : 3;
    ToolEraser.__super__.constructor.call(this, golApp, false, true);
    this.preview_color = "rgba(255,20,0,0.4)";
  }

  ToolEraser.prototype._drawPreview = function(_arg) {
    var cell_size, ctx, dc, rect, sz, x0, y0;
    x0 = _arg[0], y0 = _arg[1];
    cell_size = this.golApp.view.cell_size;
    sz = this.size * cell_size;
    dc = (this.size / 2) | 0;
    ctx = this.getOverlayContext();
    ctx.fillStyle = this.preview_color;
    this.clear_old_rect(ctx);
    rect = [(x0 - dc) * cell_size, (y0 - dc) * cell_size, sz, sz];
    ctx.fillRect.apply(ctx, rect);
    this.old_rect = rect;
    return null;
  };

  ToolEraser.prototype.on_cell_change = function(e, xy) {
    this._drawPreview(xy);
    if (this.dragging) {
      return this._erase_at(xy);
    }
  };

  ToolEraser.prototype._erase_at = function(_arg) {
    var dc, s, x, y;
    x = _arg[0], y = _arg[1];
    s = this.size;
    dc = (s / 2) | 0;
    this.golApp.gol.field.fill_box(x - dc, y - dc, x - dc + s, y - dc + s, 0);
    return this.golApp.updateCanvasBox(x - dc, y - dc, x - dc + s, y - dc + s);
  };

  ToolEraser.prototype.on_click_cell = function(e, xy) {
    return this._erase_at(xy);
  };

  return ToolEraser;

})(BaseMouseTool);

/*
#Mouse tool that draws given pattern
*/


ToolStamp = (function(_super) {
  __extends(ToolStamp, _super);

  function ToolStamp(golApp) {
    ToolStamp.__super__.constructor.call(this, golApp, true, true);
    this.preview_color = "rgba(255,255,0,0.4)";
  }

  ToolStamp.prototype._drawPreview = function(_arg) {
    var ctx, dx, dy, fig, i, size, x, x0, xx, y, y0, yy, _i, _len, _ref5, _ref6;
    x0 = _arg[0], y0 = _arg[1];
    fig = this.golApp.buffer.pattern;
    if (fig.length === 0) {
      return;
    }
    size = this.golApp.view.cell_size;
    _ref5 = this.golApp.buffer.patternExtent, dx = _ref5[0], dy = _ref5[1];
    x0 -= dx;
    y0 -= dy;
    ctx = this.getOverlayContext();
    ctx.fillStyle = this.preview_color;
    this.clear_old_rect(ctx);
    for (i = _i = 0, _len = fig.length; _i < _len; i = ++_i) {
      _ref6 = fig[i], x = _ref6[0], y = _ref6[1];
      xx = (x + x0) * size;
      yy = (y + y0) * size;
      ctx.fillRect(xx, yy, size, size);
    }
    this.old_rect = [x0 * size, y0 * size, (dx + 1) * size, (dy + 1) * size];
    return null;
  };

  ToolStamp.prototype.on_cell_change = function(e, xy) {
    return this._drawPreview(xy);
  };

  ToolStamp.prototype.on_click_cell = function(e, xy) {
    var app, buffer, extent, origin, _ref5;
    app = this.golApp;
    buffer = app.buffer;
    extent = buffer.patternExtent;
    origin = Point.subtract(xy, extent);
    (_ref5 = app.gol.field).put_cells.apply(_ref5, [buffer.pattern].concat(__slice.call(origin)));
    return app.updateCanvasBox(origin[0], origin[1], xy[0] + 1, xy[1] + 1);
  };

  return ToolStamp;

})(BaseMouseTool);

/*
Mouse tool that draws lines of 1 or 0 cells
*/


ToolDraw = (function(_super) {
  __extends(ToolDraw, _super);

  function ToolDraw(golApp) {
    ToolDraw.__super__.constructor.call(this, golApp, false, false);
    this.dragging = false;
    this.value = null;
  }

  ToolDraw.prototype.update_box = function(xy_a, xy_b) {
    var _ref5;
    return (_ref5 = this.golApp).updateCanvasBox.apply(_ref5, Point.boundBox(xy_a, xy_b));
  };

  ToolDraw.prototype.draw_at = function(x, y) {
    return this.golApp.gol.field.set(x, y, this.value);
  };

  ToolDraw.prototype.on_cell_change = function(e, xy) {
    var dxy, i, last_xy, x0, xx, y0, yy, _i, _ref5, _ref6, _ref7;
    if (this.dragging) {
      dxy = Point.subtract(xy, this.last_xy);
      _ref5 = line_pixels.apply(null, dxy), xx = _ref5[0], yy = _ref5[1];
      _ref6 = last_xy = this.last_xy, x0 = _ref6[0], y0 = _ref6[1];
      for (i = _i = 1, _ref7 = xx.length; 1 <= _ref7 ? _i < _ref7 : _i > _ref7; i = 1 <= _ref7 ? ++_i : --_i) {
        this.draw_at(x0 + xx[i], y0 + yy[i]);
      }
      return this.update_box(last_xy, xy);
    }
  };

  ToolDraw.prototype.on_click_cell = function(e, xy) {
    var x, y;
    x = xy[0], y = xy[1];
    this.value = 1 ^ this.golApp.gol.field.get(x, y);
    this.draw_at(x, y);
    return this.golApp.updateCanvasBox(x, y, x + 1, y + 1);
  };

  ToolDraw.prototype.on_mouse_out = function(e) {
    return this.dragging = false;
  };

  return ToolDraw;

})(BaseMouseTool);

/*
Mouse tool that selects areas of the field
*/


ToolSelect = (function(_super) {
  __extends(ToolSelect, _super);

  function ToolSelect(golApp) {
    ToolSelect.__super__.constructor.call(this, golApp, true, true);
    this.selection_color = "rgba(0,0,255,0.3)";
    this.xy0 = null;
    this.xy1 = null;
  }

  ToolSelect.prototype.on_mouse_up = function(e) {
    ToolSelect.__super__.on_mouse_up.call(this, e);
    return this.golApp.selection = this.selection();
  };

  ToolSelect.prototype.on_cell_change = function(e, xy) {
    if (this.dragging) {
      this.xy1 = xy;
      return this.draw_box();
    }
  };

  ToolSelect.prototype.on_click_cell = function(e, xy) {
    this.xy0 = this.xy1 = xy;
    return this.draw_box();
  };

  ToolSelect.prototype.selection = function() {
    var d, x0, x1, y0, y1, _ref5;
    if (this.xy0 && this.xy1) {
      _ref5 = Point.boundBox(this.xy0, this.xy1), x0 = _ref5[0], y0 = _ref5[1], x1 = _ref5[2], y1 = _ref5[3];
      d = this.snapping ? 1 : 0;
      return [x0, y0, x1 + d, y1 + d];
    } else {
      return [0, 0, 0, 0];
    }
  };

  ToolSelect.prototype.draw_box = function() {
    var ctx, rect, size, x0, x1, y0, y1, _ref5;
    ctx = this.getOverlayContext();
    size = this.golApp.view.cell_size;
    ctx.fillStyle = this.selection_color;
    _ref5 = this.selection(), x0 = _ref5[0], y0 = _ref5[1], x1 = _ref5[2], y1 = _ref5[3];
    rect = [x0 * size, y0 * size, (x1 - x0) * size, (y1 - y0) * size];
    this.clear_old_rect(ctx);
    this.old_rect = rect;
    return ctx.fillRect.apply(ctx, rect);
  };

  return ToolSelect;

})(BaseMouseTool);

BufferPane = (function() {
  function BufferPane(canvas, pattern, desiredSize) {
    this.canvas = canvas;
    if (pattern == null) {
      pattern = [];
    }
    this.desiredSize = desiredSize != null ? desiredSize : [64, 64];
    if (this.canvas.getContext == null) {
      throw new Error("Not a canvas");
    }
    this._bindEvents();
    this.oldRleValue = null;
    this.set(pattern);
  }

  BufferPane.prototype.updatePattern = function() {
    var canv, getCanvas;
    canv = this.canvas;
    getCanvas = function(w, h) {
      canv.width = w;
      canv.height = h;
      return canv;
    };
    return canv = drawPatternOnCanvas(getCanvas, this.pattern, this.desiredSize, [1, 24], 1);
  };

  BufferPane.prototype.set = function(pattern, update_rle) {
    var ex, ey, _ref5;
    if (update_rle == null) {
      update_rle = true;
    }
    this.pattern = pattern;
    _ref5 = Cells.extent(pattern), ex = _ref5[0], ey = _ref5[1];
    this.patternExtent = [ex + (ex & 1), ey + (ey & 1)];
    this.updatePattern();
    if (update_rle) {
      return this.toRle();
    }
  };

  BufferPane.prototype.transform = function(tfm) {
    return this.set(Cells.transform(this.pattern, tfm));
  };

  BufferPane.prototype.togglePhase = function() {
    return this.set(Cells.togglePhase(this.pattern));
  };

  BufferPane.prototype.toRle = function() {
    return E("rle-encoded").value = this.oldRleValue = Cells.to_rle(this.pattern);
  };

  BufferPane.prototype.fromRle = function() {
    var e, messageBoxElt, messageElt, rle;
    messageElt = E("rle-decode-message");
    messageBoxElt = E("rle-decode-box");
    rle = remove_whitespaces(E("rle-encoded").value);
    if (rle !== this.oldRleValue) {
      this.oldRleValue = rle;
      try {
        this.set(Cells.from_rle(rle), false);
        messageBoxElt.style.visibility = "hidden";
        return messageElt.innerHTML = "";
      } catch (_error) {
        e = _error;
        messageElt.innerHTML = "" + e;
        return messageBoxElt.style.visibility = "visible";
      }
    }
  };

  BufferPane.prototype._bindEvents = function() {
    var _this = this;
    return addDelayedListener(E("rle-encoded"), ["keypress", "blur", "change"], 200, function() {
      return _this.fromRle();
    });
  };

  return BufferPane;

})();

fill_rules = function(predefined_rules) {
  var i, name, opts, rule, _i, _len, _ref5;
  opts = E("select-rule").options;
  for (i = _i = 0, _len = predefined_rules.length; _i < _len; i = ++_i) {
    _ref5 = predefined_rules[i], name = _ref5[0], rule = _ref5[1];
    opts[i] = new Option(name, Rules.stringify(rule));
  }
  return opts[opts.length] = new Option("(User Defined)", "");
};

show_rule_diagram = function(rule, element) {
  var cells_icon, dom, elements, isFirst, j, row, x_str, x_value, y_value, _i, _j, _len, _len1;
  cells_icon = function(value) {
    return "cellicon icon-cells_" + (value.toString(16));
  };
  if (rule.length !== 16) {
    throw new Error("Function must be array of 16 elements, not\n" + rule);
  }
  dom = new DomBuilder;
  elements = [["0000", "1111"], ["1000", "0100", "0001", "0010"], ["1100", "0101", "0011", "1010"], ["1001", "0110"], ["0111", "1011", "1110", "1101"]];
  for (_i = 0, _len = elements.length; _i < _len; _i++) {
    row = elements[_i];
    dom.tag("div").CLASS("func_row");
    isFirst = true;
    for (j = _j = 0, _len1 = row.length; _j < _len1; j = ++_j) {
      x_str = row[j];
      x_value = parseInt(x_str, 2);
      y_value = rule[x_value];
      if (y_value !== x_value) {
        if (!isFirst) {
          dom.tag("span").CLASS("icon icon-separator").end();
        }
        dom.tag("span").CLASS("func_pair").tag("span").CLASS(cells_icon(x_value)).end().tag("span").CLASS("icon icon-rarrow").end().tag("span").CLASS(cells_icon(y_value)).end().end();
        isFirst = false;
      }
    }
    dom.end();
  }
  element.innerHTML = "";
  return element.appendChild(dom.finalize());
};

show_rule_properties = function(rule, element) {
  var dom, dualTransform, hasAny, invertible, population_invariance, symm, symmetries;
  symmetries = Rules.find_symmetries(rule);
  population_invariance = Rules.invariance_type(rule);
  invertible = Rules.is_invertible(rule);
  dualTransform = getDualTransform(rule);
  dom = new DomBuilder;
  dom.tag("p").text("Rule is ").tag("span").CLASS(invertible ? "green-text" : "red-text").text(invertible ? "invertible" : "non-invertible").end().text(". ");
  dom.text("Population is ").text((function() {
    switch (population_invariance) {
      case "const":
        return "constant";
      case "inv-const":
        return "constant with inverse";
      default:
        return "variable";
    }
  })()).text(".");
  dom.end();
  dom.tag("p").text("Rule is invariant to:").tag("ul");
  hasAny = false;
  for (symm in symmetries) {
    dom.tag("li").text(Transforms.getDescription(symm)).end();
    hasAny = true;
  }
  if (!hasAny) {
    dom.tag("li").text("Nothing").end();
  }
  dom.end().end();
  dom.tag("p");
  if (dualTransform[0] === null) {
    dom.text("Rule has no dual transform.");
  } else {
    if (dualTransform[0] === "iden") {
      dom.text("Rule is self-dual");
    } else {
      dom.text("Rule has dual transform: ").text(Transforms.getDescription(dualTransform[0]));
    }
  }
  dom.end();
  element.innerHTML = "";
  return element.appendChild(dom.finalize());
};

Transforms = {
  iden: "identity transform",
  rot90: "rotation by 90°",
  rot180: "rotation by 180°",
  rot270: "rotation by 270°",
  flipx: "horizontal flip",
  flipy: "vertical flip",
  flipxy: "flip across main diagonal",
  flipixy: "flip across anti-diagonal",
  negate: "negation of cells",
  flipx_neg: "horizontal flip with negation",
  flipy_neg: "vertical flip with negation",
  getDescription: function(name) {
    var txt;
    if ((txt = this[name]) != null) {
      return txt;
    } else {
      throw new Error("Unknown identity transform name: " + name);
    }
  }
};

drawPatternOnCanvas = function(canvasGetter, cells, desired_size, cell_size_limits, grid_width) {
  var DESIRED_H, DESIRED_W, canv, cellSize, cell_max, cell_min, cols, ctx, fld, rows, view, x0, y0, _ref5;
  DESIRED_W = desired_size[0], DESIRED_H = desired_size[1];
  cell_min = cell_size_limits[0], cell_max = cell_size_limits[1];
  _ref5 = Cells.bounds(cells), x0 = _ref5[0], y0 = _ref5[1], cols = _ref5[2], rows = _ref5[3];
  cols++;
  rows++;
  cols += cols % 2;
  rows += rows % 2;
  cellSize = cap(cell_min, cell_max, Math.min(DESIRED_W / cols, DESIRED_H / rows) | 0);
  if (cellSize <= 2) {
    grid_width = 0;
  }
  fld = new Array2d(cols, rows);
  fld.fill(0);
  fld.put_cells(cells, 0, 0);
  view = new FieldView(fld);
  view.cell_size = cellSize;
  view.grid_width = grid_width;
  canv = canvasGetter(cols * cellSize, rows * cellSize);
  ctx = canv.getContext("2d");
  view.draw(ctx);
  return canv;
};

LibraryPane = (function() {
  function LibraryPane(div, librarySizeElement, golApp) {
    this.div = div;
    this.librarySizeElement = librarySizeElement;
    this.golApp = golApp;
    this.key2result = {};
    this.librarySize = 0;
    this.desired_size = [80, 40];
    this._createTable();
    this.name = "";
    this.modified = false;
    this.updateLibrarySize();
    this.updateLibraryName();
  }

  LibraryPane.prototype._createTable = function() {
    var dom, hdr, _i, _len, _ref5;
    dom = new DomBuilder("table");
    dom.a("class", "library-table").tag("thead").tag("tr");
    _ref5 = ["Pattern", "Population", "Period", "Offset", "V", "RLE", "Count", ""];
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      hdr = _ref5[_i];
      dom.tag("th").text(hdr).end();
    }
    dom.end().end().tag("tbody").store("library_body");
    this.library_body = dom.vars.library_body;
    return this.div.appendChild(dom.finalize());
  };

  LibraryPane.prototype.put = function(result) {
    var record, rle;
    if (result == null) {
      return;
    }
    rle = Cells.to_rle(result.cells);
    record = {
      result: result,
      count: 1,
      counter: null,
      key: rle
    };
    this._putRecord(record);
    return this.updateLibrarySize();
  };

  LibraryPane.prototype.defaultLibraryForRule = function(rule) {
    var sRule, _ref5;
    sRule = Rules.stringify(rule);
    return (_ref5 = Rule2Name[Rules.stringify(rule)]) != null ? _ref5 : "Default:[" + sRule + "]";
  };

  LibraryPane.prototype.has = function(result) {
    var rle;
    rle = Cells.to_rle(result.cells);
    return rle in this.key2result;
  };

  LibraryPane.prototype.hasDual = function(result, rule) {
    var rle;
    if (result.dx != null) {
      rle = Cells.getDualSpaceship(result.cells, rule, result.dx, result.dy);
      return rle in this.key2result;
    } else {
      return false;
    }
  };

  LibraryPane.prototype._putRecord = function(record) {
    var old_record;
    old_record = this.key2result[record.key];
    this.modified = true;
    if (old_record != null) {
      old_record.count += record.count;
      return this.updateRecord(old_record);
    } else {
      this.key2result[record.key] = record;
      this.addRecord(record);
      return this.librarySize += 1;
    }
  };

  LibraryPane.prototype.updateLibrarySize = function() {
    this.librarySizeElement.innerHTML = "" + this.librarySize;
    return E("library-modified-elem").style.visibility = this.modified ? "visible" : "hidden";
  };

  LibraryPane.prototype.updateLibraryName = function() {
    var name;
    E("library-name").innerHTML = "";
    name = this.name || "[New Library]";
    return E("library-name").appendChild(document.createTextNode(name));
  };

  LibraryPane.prototype.updateRecord = function(record) {
    return record.counter.innerHTML = "" + record.count;
  };

  LibraryPane.prototype.copyRecord = function(rec) {
    return {
      result: rec.result,
      count: rec.count,
      key: rec.key
    };
  };

  LibraryPane.prototype.dumpToStorage = function(storage, name) {
    if (storage == null) {
      throw new Error("No storage");
    }
    storage[name] = this.data2string();
    this.name = name;
    return this.modified = false;
  };

  LibraryPane.prototype.data2string = function() {
    var key, s;
    s = (function() {
      var _results;
      _results = [];
      for (key in this.key2result) {
        _results.push(this.copyRecord(this.key2result[key]));
      }
      return _results;
    }).call(this);
    return JSON.stringify(s);
  };

  LibraryPane.prototype.showStoredData = function() {
    return E("library-json-data").value = this.data2string();
  };

  LibraryPane.prototype.importData = function() {
    var e, elt;
    try {
      elt = E("library-json-data");
      this._importData(JSON.parse(elt.value));
      return elt.value = "";
    } catch (_error) {
      e = _error;
      return alert("Failed to import JSON: " + e);
    }
  };

  LibraryPane.prototype.clear = function() {
    this.key2result = {};
    this.librarySize = 0;
    this.library_body.innerHTML = "";
    this.modified = false;
    this.name = "";
    this.updateLibrarySize();
    return this.updateLibraryName();
  };

  LibraryPane.prototype._importData = function(stored) {
    var rec, _i, _len, _ref5;
    for (_i = 0, _len = stored.length; _i < _len; _i++) {
      rec = stored[_i];
      rec.counter = null;
      if (_ref5 = rec.key, __indexOf.call(this.key2result, _ref5) < 0) {
        this._putRecord(rec);
      }
    }
    this.updateLibrarySize();
    return null;
  };

  LibraryPane.prototype._libraryKey = function(name) {
    return "library-" + name;
  };

  LibraryPane.prototype.load = function(storage, name) {
    if (!((this._libraryKey(name)) in storage)) {
      alert("Library \"" + name + "\" is not present in the storage.");
      return;
    }
    if (this.modified) {
      if (!confirm("Current library has unsaved modifications. Do you want to discard them?")) {
        return;
      }
    }
    this.clear();
    this.name = name;
    this._importData(JSON.parse(storage[this._libraryKey(name)]));
    this.modified = false;
    this.updateLibrarySize();
    return this.updateLibraryName();
  };

  LibraryPane.prototype.save = function(storage, newName) {
    var name;
    if (newName == null) {
      newName = false;
    }
    if ((!newName) && (!this.modified)) {
      return;
    }
    name = this.name;
    if (newName || (name === "")) {
      name = prompt("Please enter library name", this.defaultLibraryForRule(this.golApp.gol.rule));
      if (!name) {
        return;
      }
      if ((this._libraryKey(name)) in storage) {
        if (!confirm("Library " + name + " already exists in the storage. Do you want to overwrite it?")) {
          return;
        }
      }
      this.name = name;
      this.updateLibraryName();
    }
    storage[this._libraryKey(name)] = this.data2string();
    this.modified = false;
    return this.updateLibrarySize();
  };

  LibraryPane.prototype.deleteCurrent = function(storage) {
    if (!this.name) {
      alert("Library is not saved");
      return;
    }
    delete storage[this._libraryKey(this.name)];
    return this.clear();
  };

  LibraryPane.prototype.addRecord = function(record) {
    var canv, dom, makeCanvas, result, v_str, _ref5, _ref6, _ref7,
      _this = this;
    result = record.result;
    makeCanvas = function(imgW, imgH) {
      return makeElement("canvas", [["width", imgW], ["height", imgH]]);
    };
    canv = drawPatternOnCanvas(makeCanvas, result.cells, this.desired_size, [1, 24], 1);
    v_str = result.period != null ? rational2str(Math.max(Math.abs(result.dx), Math.abs(result.dy)), result.period) : "?";
    dom = new DomBuilder("tr");
    dom.CLASS("pattern-report").tag("td").tag("div").CLASS("lib-pattern-background").tag("a").store("aSelect").a("href", "#").a("title", "Click to select pattern").append(canv).end().end().end().tag("td").text(result.cells.length).end().tag("td").text((_ref7 = result.period) != null ? _ref7 : "?").end().tag("td").text("(" + ((_ref5 = result.dx) != null ? _ref5 : "?") + "," + ((_ref6 = result.dy) != null ? _ref6 : "?") + ")").end().tag("td").text(v_str).end().tag("td").tag("div").CLASS("rle-box").text(Cells.to_rle(result.cells)).end().end().tag("td").store("cnt").text(record.count).end().tag("td").tag("a").a("href", "#").CLASS("button").store("closebtn").tag("span").CLASS("icon icon-clearall").a("title", "Remove record").text("X").end().end().end();
    record.counter = dom.vars.cnt;
    dom.vars.closebtn.addEventListener("click", function(e) {
      _this._removeItem(record.key);
      return e.preventDefault();
    });
    dom.vars.aSelect.addEventListener("click", function(e) {
      return _this.golApp.buffer.set(result.cells);
    });
    return this.library_body.insertBefore((record.element = dom.finalize()), null);
  };

  LibraryPane.prototype._removeItem = function(key) {
    var record;
    record = this.key2result[key];
    delete this.key2result[key];
    record.element.parentNode.removeChild(record.element);
    this.librarySize -= 1;
    this.modified = true;
    return this.updateLibrarySize();
  };

  LibraryPane.prototype.filter = function(predicate) {
    var key, to_remove, _i, _len, _results;
    to_remove = [];
    for (key in this.key2result) {
      if (!predicate(this.key2result[key])) {
        to_remove.push(key);
      }
    }
    _results = [];
    for (_i = 0, _len = to_remove.length; _i < _len; _i++) {
      key = to_remove[_i];
      _results.push(this._removeItem(key));
    }
    return _results;
  };

  return LibraryPane;

})();

SpaceshipCatcher = (function() {
  function SpaceshipCatcher(on_pattern, max_size, reseed_period) {
    this.on_pattern = on_pattern;
    this.max_size = max_size != null ? max_size : 20;
    this.reseed_period = reseed_period != null ? reseed_period : 300000;
    this.search_area = 1;
    this.spaceships_found = [];
  }

  SpaceshipCatcher.prototype.scan = function(gol) {
    var f, pick, rule, x, y, _i, _j, _k, _l, _ref5, _ref6, _ref7, _ref8, _ref9,
      _this = this;
    f = gol.field;
    rule = gol.rule;
    pick = function(x, y) {
      var fig, x0, y0;
      x0 = gol.snap_below(x);
      y0 = gol.snap_below(y);
      fig = f.pick_pattern_at(x, y, x0, y0, true);
      if (fig.length <= _this.max_size) {
        return _this.on_pattern(fig, rule);
      }
    };
    for (y = _i = 0, _ref5 = this.search_area; _i < _ref5; y = _i += 1) {
      for (x = _j = 0, _ref6 = f.width; _j < _ref6; x = _j += 1) {
        if (f.get(x, y) !== 0) {
          pick(x, y);
        }
      }
    }
    for (y = _k = _ref7 = this.search_area, _ref8 = f.height; _k < _ref8; y = _k += 1) {
      for (x = _l = 0, _ref9 = this.search_area; _l < _ref9; x = _l += 1) {
        if (f.get(x, y) !== 0) {
          pick(x, y);
        }
      }
    }
    return null;
  };

  return SpaceshipCatcher;

})();

loadExternalCSS = function(cssHref) {
  var link;
  link = document.createElement("link");
  link.rel = "stylesheet";
  link.type = "text/css";
  link.href = cssHref;
  return document.getElementsByTagName("head")[0].appendChild(link);
};

(function() {
  var btnGroupFeatures, btnGroupTools, btnId, button2panel, fastButton, golApp, panelId, sz;
  if (!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1")) {
    loadExternalCSS("icons-png.css");
  }
  golApp = new GolApplication([64, 64], "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15", "overlay-container", "canvas", "overlay", "time");
  fastButton = function(id, handler) {
    var e;
    e = E(id);
    e.addEventListener("click", function(e) {
      e.preventDefault();
      if (!golApp.ghost_click_detector.isGhost) {
        return handler(e);
      }
    });
    return e.addEventListener("touchstart", function(e) {
      e.preventDefault();
      golApp.ghost_click_detector.onTouch();
      return handler(e);
    });
  };
  fill_rules([["Billiard Ball Machine", Rules.parse("0;8;4;3;2;5;9;7;1;6;10;11;12;13;14;15", ";")], ["Bounce gas", Rules.parse("0;8;4;3;2;5;9;14; 1;6;10;13;12;11;7;15", ";")], ["HPP Gas", Rules.parse("0;8;4;12;2;10;9; 14;1;6;5;13;3;11;7;15", ";")], ["Rotations", Rules.parse("0;2;8;12;1;10;9; 11;4;6;5;14;3;7;13;15", ";")], ["Rotations II", Rules.parse("0;2;8;12;1;10;9; 13;4;6;5;7;3;14;11;15", ";")], ["Rotations III", Rules.parse("0;4;1;10;8;3;9;11; 2;6;12;14;5;7;13;15", ";")], ["Rotations IV", Rules.parse("0;4;1;12;8;10;6;14; 2;9;5;13;3;11;7;15", ";")], ["Sand", Rules.parse("0;4;8;12;4;12;12;13; 8;12;12;14;12;13;14;15", ";")], ["String Thing", NamedRules.stringThing], ["String Thing II", Rules.parse("0;1;2;12;4;10;6;7;8; 9;5;11;3;13;14;15", ";")], ["Swap On Diag", Rules.parse("0;8;4;12;2;10;6;14; 1;9;5;13;3;11;7;15", ";")], ["Critters", NamedRules.critters], ["Tron", NamedRules.tron], ["Double Rotate", NamedRules.doubleRotate], ["Single Rotate", NamedRules.singleRotate]]);
  fastButton("clear_field", function() {
    return golApp.do_clear();
  });
  fastButton("go-next", function() {
    return golApp.doStep();
  });
  fastButton("go-back", function() {
    return golApp.doReverseStep();
  });
  fastButton("rplay", function() {
    return golApp.startPlayer(-1);
  });
  fastButton("play", function() {
    return golApp.startPlayer(1);
  });
  fastButton("stop", function() {
    return golApp.stopPlayer();
  });
  E("reset-timer").onclick = function() {
    return golApp.reset_time();
  };
  E("set_rule").onclick = function() {
    var rule;
    rule = golApp.set_rule(E("rule").value);
    return selectOption(E("select-rule"), Rules.stringify(golApp.gol.rule), "");
  };
  fastButton("clear-selection", function() {
    return golApp.clear_selection();
  });
  fastButton("clear-nonselection", function() {
    return golApp.clear_nonselection();
  });
  fastButton("selection-random", function() {
    return golApp.random_fill_selection(parseFloat(E("random-fill-percent").value) * 0.01);
  });
  fastButton("selection-analyze", function() {
    return golApp.analyzeSelection();
  });
  E("speed-show-every").onchange = function() {
    return golApp.step_size = parseInt(E("speed-show-every").value);
  };
  E("speed-frame-delay").onchange = function(e) {
    return golApp.setDelay(parseInt(E("speed-frame-delay").value));
  };
  E("select-rule").onchange = function() {
    var rule;
    if ((rule = E("select-rule").value) !== "") {
      golApp.set_rule(rule);
      return E("rule").value = Rules.stringify(golApp.gol.rule);
    }
  };
  E("select-style").onchange = function() {
    var sz;
    sz = parseInt(E("select-style").value, 10);
    return golApp.setCellSize(sz);
  };
  E("show-grid").onchange = function() {
    return golApp.setShowGrid(E("show-grid").checked);
  };
  btnGroupTools = new ButtonGroup(E("btn-group-tools"), "a", "btn-tool-draw");
  btnGroupTools.addEventListener("change", function(e, id) {
    var tool;
    tool = (function() {
      switch (id) {
        case "btn-tool-draw":
          return "draw";
        case "btn-tool-select":
          return "select";
        case "btn-tool-stamp":
          return "stamp";
        case "btn-tool-erase":
          return "eraser";
      }
    })();
    e.preventDefault();
    return golApp.setMouseTool(golApp.mouse_tools[tool]);
  });
  btnGroupFeatures = new ButtonGroup(E("btn-group-features"), "a", "feature-rule-details");
  button2panel = {
    "feature-rule-details": "rule-info-pane",
    "feature-gif-recorder": "gif-recorder-pane",
    "feature-library": "library-pane",
    "feature-settings": "settings-pane"
  };
  for (btnId in button2panel) {
    panelId = button2panel[btnId];
    if (btnId !== "feature-rule-details") {
      E(panelId).style.display = "none";
    }
  }
  btnGroupFeatures.addEventListener("change", function(e, id, oldId) {
    if (oldId !== null) {
      E(button2panel[oldId]).style.display = "none";
    }
    E(button2panel[id]).style.display = "block";
    return e.preventDefault();
  });
  E("gif-start").onclick = nodefault(function() {
    return golApp.start_gif_recorder();
  });
  E("gif-stop").onclick = nodefault(function() {
    return golApp.stopGifRecorder(true);
  });
  E("gif-clear").onclick = nodefault(function() {
    return golApp.gifRecorderClear();
  });
  E("lib-save").onclick = function() {
    return golApp.saveLibrary(false);
  };
  E("lib-save-as").onclick = function() {
    return golApp.saveLibrary(true);
  };
  E("lib-export-json").onclick = function() {
    return golApp.library.showStoredData();
  };
  E("lib-import-json").onclick = function() {
    return golApp.library.importData();
  };
  E("lib-new").onclick = function() {
    return golApp.library.clear();
  };
  E("lib-erase").onclick = function() {
    return golApp.deleteCurrentLibrary();
  };
  E("list-libraries").onchange = function() {
    var e, libName;
    libName = E("list-libraries").value;
    if (libName) {
      try {
        return golApp.library.load(localStorage, libName);
      } catch (_error) {
        e = _error;
        return alert(e);
      }
    }
  };
  E("lib-remove-composites").onclick = function() {
    var e, isnt_composite;
    isnt_composite = function(record) {
      var groups;
      groups = splitPattern(golApp.gol.rule, record.result.cells, record.result.period);
      return groups.length <= 1;
    };
    try {
      return golApp.library.filter(isnt_composite);
    } catch (_error) {
      e = _error;
      return alert("Error:" + e);
    }
  };
  E("lib-load-default").onclick = function() {
    return golApp.library.load(localStorage, golApp.library.defaultLibraryForRule(golApp.gol.rule));
  };
  E("select-size").onchange = function() {
    var cols, e, rows, _ref5;
    try {
      _ref5 = JSON.parse(E("select-size").value), cols = _ref5[0], rows = _ref5[1];
      golApp.setSize(cols, rows);
      return selectOrAddOption(E("select-style"), golApp.view.cell_size);
    } catch (_error) {
      e = _error;
      return null;
    }
  };
  fastButton("toggle-catcher", function() {
    if (golApp.spaceship_catcher !== null) {
      return golApp.disable_spaceship_catcher();
    } else {
      return golApp.enable_spaceship_catcher();
    }
  });
  E("library-json-data").onfocus = E("rle-encoded").onfocus = function() {
    var _this = this;
    return window.setTimeout((function() {
      return _this.select();
    }), 100);
  };
  E("analysis-result-to-library").onclick = function() {
    return golApp.analysisResultToLibrary();
  };
  E("analysis-result-close").onclick = function() {};
  E("analysis-result").onclick = E("analysis-result-close").onclick = function() {
    return E("analysis-result").style.display = "none";
  };
  fastButton("pattern-rotate-cw", function() {
    return golApp.buffer.transform([0, -1, 1, 0]);
  });
  fastButton("pattern-rotate-ccw", function() {
    return golApp.buffer.transform([0, 1, -1, 0]);
  });
  fastButton("pattern-flip-h", function() {
    return golApp.buffer.transform([-1, 0, 0, 1]);
  });
  fastButton("pattern-flip-v", function() {
    return golApp.buffer.transform([1, 0, 0, -1]);
  });
  fastButton("pattern-toggle-phase", function() {
    return golApp.buffer.togglePhase();
  });
  fastButton("pattern-from-selection", function() {
    return golApp.copyToBuffer();
  });
  E("app-create-link").onclick = function() {
    return E("url-output").value = golApp.encode_state_in_url();
  };
  E("url-output").onfocus = function() {
    var _this = this;
    return window.setTimeout((function() {
      return _this.select();
    }), 100);
  };
  golApp.step_size = parseInt(E("speed-show-every").value);
  golApp.step_delay = parseInt(E("speed-frame-delay").value);
  golApp.set_rule(E("select-rule").value);
  golApp.initialize();
  E("rule").value = Rules.stringify(golApp.gol.rule);
  selectOrAddOption(E("speed-show-every"), golApp.step_size);
  selectOrAddOption(E("speed-frame-delay"), golApp.step_delay, "" + golApp.step_delay + "ms");
  sz = golApp.gol.field.size();
  selectOrAddOption(E("select-size"), JSON.stringify(sz), "" + sz[0] + " x " + sz[1]);
  selectOrAddOption(E("select-style"), golApp.view.cell_size);
  E("show-grid").checked = golApp.view.grid_width > 0;
  return golApp.updateLibrariesList();
})();

/*
//@ sourceMappingURL=application.map
*/

},{"./canvas_util":2,"./cells":3,"./dom_builder":4,"./field_view":5,"./math_util":6,"./parseuri":7,"./reversible_ca":8,"./rle":9,"./rules":10}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
exports.getCanvasCursorPosition = function(e, canvas) {
  var rect;
  if (e.type === "touchmove" || e.type === "touchstart" || e.type === "touchend") {
    e = e.touches[0];
  }
  if (e.clientX != null) {
    rect = canvas.getBoundingClientRect();
    return [e.clientX - rect.left, e.clientY - rect.top];
  }
};

exports.getCanvasCursorPosition1 = function(e, canvas) {
  var dbody, delem, x, y;
  if (e.type === "touchmove" || e.type === "touchstart" || e.type === "touchend") {
    x = e.touches[0].pageX;
    y = e.touches[0].pageY;
  } else if (e.pageX != null) {
    x = e.pageX;
    y = e.pageY;
  } else {
    dbody = document.body;
    delem = document.documentElement;
    x = e.clientX + dbody.scrollLeft + delem.scrollLeft;
    y = e.clientY + dbody.scrollTop + delem.scrollTop;
  }
  x -= canvas.offsetLeft;
  y -= canvas.offsetTop;
  return [x, y];
};

/*
//@ sourceMappingURL=canvas_util.map
*/

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Array2d, Bits, Cells, MargolusNeighborehoodField, Maximizer, Point, Rules, div, evaluateCellList, evaluateLabelledCellList, extend_array, getDualTransform, mod, module_math_util, module_reversible_ca, module_rle, module_rules, parse_rle, transformMatrix2BitBlockMap;

module_rle = require("./rle");

module_rules = require("./rules");

module_math_util = require("./math_util");

module_reversible_ca = require("./reversible_ca");

parse_rle = module_rle.parse_rle;

Rules = module_rules.Rules, Bits = module_rules.Bits;

Maximizer = module_math_util.Maximizer, mod = module_math_util.mod, div = module_math_util.div;

MargolusNeighborehoodField = module_reversible_ca.MargolusNeighborehoodField, Array2d = module_reversible_ca.Array2d;

exports.Cells = Cells = {
  areEqual: function(l1, l2) {
    var i, xy1, xy2, _i, _ref;
    if (l1.length !== l2.length) {
      return false;
    }
    for (i = _i = 0, _ref = l1.length; _i < _ref; i = _i += 1) {
      xy1 = l1[i];
      xy2 = l2[i];
      if (xy1[0] !== xy2[0] || xy1[1] !== xy2[1]) {
        return false;
      }
    }
    return true;
  },
  sortXY: function(lst) {
    return lst.sort(function(_arg, _arg1) {
      var x1, x2, y1, y2;
      x1 = _arg[0], y1 = _arg[1];
      x2 = _arg1[0], y2 = _arg1[1];
      return (y1 - y2) || (x1 - x2);
    });
  },
  bounds: function(lst) {
    var i, x, x0, x1, y, y0, y1, _i, _ref, _ref1, _ref2, _ref3;
    if (lst.length === 0) {
      return [0, 0, 0, 0];
    }
    _ref1 = (_ref = lst[0], x0 = _ref[0], y0 = _ref[1], _ref), x1 = _ref1[0], y1 = _ref1[1];
    for (i = _i = 1, _ref2 = lst.length; _i < _ref2; i = _i += 1) {
      _ref3 = lst[i], x = _ref3[0], y = _ref3[1];
      x0 = Math.min(x0, x);
      x1 = Math.max(x1, x);
      y0 = Math.min(y0, y);
      y1 = Math.max(y1, y);
    }
    return [x0, y0, x1, y1];
  },
  transform: function(lst, tfm, need_normalize) {
    var lst1, t00, t01, t10, t11, x, x1, y, y1;
    if (need_normalize == null) {
      need_normalize = true;
    }
    t00 = tfm[0], t01 = tfm[1], t10 = tfm[2], t11 = tfm[3];
    lst1 = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = lst.length; _i < _len; _i++) {
        _ref = lst[_i], x = _ref[0], y = _ref[1];
        x += 0.5;
        y += 0.5;
        x1 = (t00 * x + t01 * y - 0.5) | 0;
        y1 = (t10 * x + t11 * y - 0.5) | 0;
        _results.push([x1, y1]);
      }
      return _results;
    })();
    if (need_normalize) {
      return this.normalize(lst1);
    } else {
      return lst1;
    }
  },
  normalize: function(lst1) {
    return this.sortXY(this.normalizeXY(lst1));
  },
  normalizeXY: function(lst1) {
    var xmin, ymin, _ref;
    _ref = this.bounds(lst1), xmin = _ref[0], ymin = _ref[1];
    xmin -= mod(xmin, 2);
    ymin -= mod(ymin, 2);
    return this.offset(lst1, -xmin, -ymin);
  },
  togglePhase: function(cells) {
    var cells1, x, y;
    cells1 = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = cells.length; _i < _len; _i++) {
        _ref = cells[_i], x = _ref[0], y = _ref[1];
        _results.push([x + 1, y + 1]);
      }
      return _results;
    })();
    return Cells.normalizeXY(cells1);
  },
  offset: function(lst, dx, dy) {
    var xy, _i, _len;
    for (_i = 0, _len = lst.length; _i < _len; _i++) {
      xy = lst[_i];
      xy[0] += dx;
      xy[1] += dy;
    }
    return lst;
  },
  extent: function(lst) {
    var x1, y1, _, _ref;
    _ref = this.bounds(lst), _ = _ref[0], _ = _ref[1], x1 = _ref[2], y1 = _ref[3];
    return [x1, y1];
  },
  find: function(lst, _arg) {
    var i, x, xi, y, yi, _i, _len, _ref;
    x = _arg[0], y = _arg[1];
    for (i = _i = 0, _len = lst.length; _i < _len; i = ++_i) {
      _ref = lst[i], xi = _ref[0], yi = _ref[1];
      if (xi === x && yi === y) {
        return i;
      }
    }
    return null;
  },
  /*
  Convert list of alive cells to RLE. List of cells must be sorted by Y, then by X, and coordinates of origin must be at (0,0)
  */

  to_rle: function(cells) {
    var appendNumber, count, dx, dy, endWritingBlock, i, rle, x, xi, y, yi, _i, _len, _ref;
    rle = "";
    count = 0;
    appendNumber = function(n, c) {
      if (n > 1) {
        rle += n;
      }
      return rle += c;
    };
    endWritingBlock = function() {
      if (count > 0) {
        appendNumber(count, "o");
        return count = 0;
      }
    };
    x = -1;
    y = 0;
    for (i = _i = 0, _len = cells.length; _i < _len; i = ++_i) {
      _ref = cells[i], xi = _ref[0], yi = _ref[1];
      dy = yi - y;
      if (dy < 0) {
        throw new Error("Cell list are not sorted by Y");
      }
      if (dy > 0) {
        endWritingBlock();
        appendNumber(dy, "$");
        x = -1;
        y = yi;
      }
      dx = xi - x;
      if (dx <= 0) {
        throw new Error("Cell list is not sorted by X");
      }
      if (dx === 1) {
        count++;
      } else if (dx > 1) {
        endWritingBlock();
        appendNumber(dx - 1, "b");
        count = 1;
      }
      x = xi;
    }
    endWritingBlock();
    return rle;
  },
  /*
  Convert RLE-encoded configutaion back to cell list
  */

  from_rle: function(rle) {
    var cells;
    cells = [];
    parse_rle(rle, function(x, y) {
      return cells.push([x, y]);
    });
    return cells;
  },
  energy: function(lst) {
    var e, i, j, n, x1, x2, y1, y2, _i, _j, _len, _ref, _ref1, _ref2;
    n = lst.length;
    e = 0;
    for (i = _i = 0, _len = lst.length; _i < _len; i = ++_i) {
      _ref = lst[i], x1 = _ref[0], y1 = _ref[1];
      for (j = _j = _ref1 = i + 1; _ref1 <= n ? _j < n : _j > n; j = _ref1 <= n ? ++_j : --_j) {
        _ref2 = lst[j], x2 = _ref2[0], y2 = _ref2[1];
        e += 1.0 / Math.pow(Math.abs(x1 - x2) + Math.abs(y1 - y2), 2);
      }
    }
    return e;
  },
  _rotations: [[1, 0, 0, 1], [0, 1, -1, 0], [-1, 0, 0, -1], [0, -1, 1, 0]],
  _find_normalizing_rotation: function(dx, dy) {
    var dx1, dy1, t, _i, _len, _ref;
    _ref = this._rotations;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      dx1 = dx * t[0] + dy * t[1];
      dy1 = dx * t[2] + dy * t[3];
      if (dx1 > 0 && dy1 >= 0) {
        return [dx1, dy1, t];
      }
    }
    throw new Error("Impossible to rotate vector (" + dx + "," + dy + ") to the positive direction");
  },
  analyze: function(pattern, rule, max_iters, stop_on_border_hit) {
    var bestPatternSearch, cells_best, curPattern, cycle_found, iter, result, sandbox, sandbox_size, vacuum_period, x0, x1, xrange, y0, y1, yrange, _i, _ref, _ref1, _ref2;
    if (max_iters == null) {
      max_iters = 2048;
    }
    if (stop_on_border_hit == null) {
      stop_on_border_hit = true;
    }
    if (!pattern) {
      throw new Error("Pattern undefined");
    }
    if (!rule) {
      throw new Error("Rule undefined");
    }
    vacuum_period = Rules.vacuum_period(rule);
    if (vacuum_period == null) {
      throw new Error("Empty field is not periodic for this rule. Analysis impossible");
    }
    pattern = this.normalize(pattern);
    _ref = this.extent(pattern), xrange = _ref[0], yrange = _ref[1];
    sandbox_size = 64 + 2 * Math.max(xrange + yrange, pattern.length);
    sandbox = new MargolusNeighborehoodField(new Array2d(sandbox_size, sandbox_size), rule);
    sandbox.field.fill(0);
    x0 = sandbox.snap_below(div(sandbox_size - xrange, 2));
    y0 = sandbox.snap_below(div(sandbox_size - yrange, 2));
    sandbox.field.put_cells(pattern, x0, y0);
    bestPatternSearch = new Maximizer(this.energy);
    bestPatternSearch.put(pattern);
    cycle_found = false;
    for (iter = _i = 1; _i <= max_iters; iter = _i += 1) {
      sandbox.transform();
      if (iter % vacuum_period !== 0) {
        continue;
      }
      if (stop_on_border_hit) {
        if (sandbox.field.is_nonempty(0, 0, sandbox_size, 1) || sandbox.field.is_nonempty(0, 0, 1, sandbox_size)) {
          break;
        }
      }
      curPattern = sandbox.field.get_cells(0, 0, sandbox_size, sandbox_size);
      _ref1 = this.bounds(curPattern), x1 = _ref1[0], y1 = _ref1[1];
      x1 = sandbox.snap_below(x1);
      y1 = sandbox.snap_below(y1);
      this.offset(curPattern, -x1, -y1);
      if (this.areEqual(pattern, curPattern)) {
        cycle_found = true;
        break;
      }
      bestPatternSearch.put(curPattern);
    }
    result = {
      analyzed_generations: max_iters
    };
    cells_best = bestPatternSearch.getArg();
    if (cycle_found) {
      _ref2 = this.canonicalize_spaceship(cells_best, rule, x1 - x0, y1 - y0), cells_best = _ref2[0], result.dx = _ref2[1], result.dy = _ref2[2];
      result.period = iter;
    }
    result.cells = cells_best;
    return result;
  },
  canonicalize_spaceship: function(pattern, rule, dx, dy) {
    var t, _ref;
    if (dx !== 0 || dy !== 0) {
      if (Rules.is_transposable_with(rule, Bits.rotate)) {
        _ref = this._find_normalizing_rotation(dx, dy), dx = _ref[0], dy = _ref[1], t = _ref[2];
        pattern = this.transform(pattern, t);
      }
    }
    return [pattern, dx, dy];
  },
  getDualSpaceship: function(pattern, rule, dx, dy) {
    var dualPattern, dx1, dy1, name, tfm, _, _ref;
    _ref = getDualTransform(rule), name = _ref[0], tfm = _ref[1], _ = _ref[2];
    if (name === null) {
      return [null];
    }
    dualPattern = Cells.togglePhase(Cells.transform(pattern, tfm));
    dx1 = -(dx * tfm[0] + dy * tfm[1]);
    dy1 = -(dx * tfm[2] + dy * tfm[3]);
    return Cells.canonicalize_spaceship(dualPattern, rule, dx1, dy1);
  }
};

exports.Point = Point = {
  equal: function(_arg, _arg1) {
    var x0, x1, y0, y1;
    x0 = _arg[0], y0 = _arg[1];
    x1 = _arg1[0], y1 = _arg1[1];
    return x0 === x1 && y0 === y1;
  },
  subtract: function(_arg, _arg1) {
    var x0, x1, y0, y1;
    x0 = _arg[0], y0 = _arg[1];
    x1 = _arg1[0], y1 = _arg1[1];
    return [x0 - x1, y0 - y1];
  },
  add: function(_arg, _arg1) {
    var x0, x1, y0, y1;
    x0 = _arg[0], y0 = _arg[1];
    x1 = _arg1[0], y1 = _arg1[1];
    return [x0 + x1, y0 + y1];
  },
  isZero: function(_arg) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return x === 0 && y === 0;
  },
  scale: function(_arg, k) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return [x * k, y * k];
  },
  scaleRound: function(_arg, k) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return [x * k | 0, y * k | 0];
  },
  corners: function(_arg, _arg1) {
    var xa, xb, ya, yb;
    xa = _arg[0], ya = _arg[1];
    xb = _arg1[0], yb = _arg1[1];
    return [[Math.min(xa, xb), Math.min(ya, yb)], [Math.max(xa, xb), Math.max(ya, yb)]];
  },
  boundBox: function(_arg, _arg1) {
    var xa, xb, ya, yb;
    xa = _arg[0], ya = _arg[1];
    xb = _arg1[0], yb = _arg1[1];
    return [Math.min(xa, xb), Math.min(ya, yb), Math.max(xa, xb) + 1, Math.max(ya, yb) + 1];
  },
  updateBoundBox: function(bbox, _arg) {
    var x, y;
    x = _arg[0], y = _arg[1];
    bbox[0] = Math.min(bbox[0], x);
    bbox[1] = Math.min(bbox[1], y);
    bbox[2] = Math.max(bbox[2], x);
    bbox[3] = Math.max(bbox[3], y);
    return bbox;
  }
};

/*
# Calculates next generation of the cell list, without using field.
# Coordinates are not limited.
# List must contain 3-tuples: x,y,v; where v!=0
*/


exports.evaluateLabelledCellList = evaluateLabelledCellList = function(rule, cells, phase, on_join_labels) {
  var a, b, b_x, b_y, block, block2cells, c, d, dx, dy, idx, key, merged_label, transformed, v, x, y, y_code, _i, _len, _ref, _ref1, _ref2;
  if (on_join_labels == null) {
    on_join_labels = null;
  }
  if (rule[0] !== 0) {
    throw new Error("Rule has instable vacuum and not supported.");
  }
  block2cells = {};
  for (_i = 0, _len = cells.length; _i < _len; _i++) {
    _ref = cells[_i], x = _ref[0], y = _ref[1], v = _ref[2];
    x += phase;
    y += phase;
    dx = x & 1;
    dy = y & 1;
    idx = dx + dy * 2;
    b_x = x >> 1;
    b_y = y >> 1;
    key = "" + b_x + " " + b_y;
    block = (_ref1 = block2cells[key]) != null ? _ref1 : (block2cells[key] = [0, 0, 0, 0, b_x, b_y]);
    block[idx] = v;
  }
  transformed = [];
  for (key in block2cells) {
    _ref2 = block2cells[key], a = _ref2[0], b = _ref2[1], c = _ref2[2], d = _ref2[3], b_x = _ref2[4], b_y = _ref2[5];
    b_x = (b_x << 1) - phase;
    b_y = (b_y << 1) - phase;
    y_code = rule[(a !== 0) + ((b !== 0) << 1) + ((c !== 0) << 2) + ((d !== 0) << 3)];
    merged_label = a || b || c || d;
    if (y_code & 1) {
      transformed.push([b_x, b_y, merged_label]);
    }
    if (y_code & 2) {
      transformed.push([b_x + 1, b_y, merged_label]);
    }
    if (y_code & 4) {
      transformed.push([b_x, b_y + 1, merged_label]);
    }
    if (y_code & 8) {
      transformed.push([b_x + 1, b_y + 1, merged_label]);
    }
    if (on_join_labels != null) {
      if (a && (a !== merged_label)) {
        on_join_labels(merged_label, a);
      }
      if (b && (b !== merged_label)) {
        on_join_labels(merged_label, b);
      }
      if (c && (c !== merged_label)) {
        on_join_labels(merged_label, c);
      }
      if (d && (d !== merged_label)) {
        on_join_labels(merged_label, d);
      }
    }
  }
  return transformed;
};

exports.getDualTransform = getDualTransform = function(rule) {
  var blockTfm, isDualBlockTfm, name, tfm, transforms, _i, _len, _ref;
  transforms = [["iden", [1, 0, 0, 1]], ["rot90", [0, 1, -1, 0]], ["rot180", [-1, 0, 0, -1]], ["rot270", [0, -1, 1, 0]], ["flipx", [-1, 0, 0, 1]], ["flipy", [1, 0, 0, -1]], ["flipxy", [0, 1, 1, 0]], ["flipixy", [0, -1, -1, 0]]];
  isDualBlockTfm = function(f, t, name) {
    var x, _i;
    for (x = _i = 0; _i <= 15; x = ++_i) {
      if (f[t[f[x]]] !== t[x]) {
        return false;
      }
    }
    return true;
  };
  for (_i = 0, _len = transforms.length; _i < _len; _i++) {
    _ref = transforms[_i], name = _ref[0], tfm = _ref[1];
    blockTfm = transformMatrix2BitBlockMap(tfm);
    if (isDualBlockTfm(rule, blockTfm, name)) {
      return [name, tfm, blockTfm];
    }
  }
  return [null];
};

exports.transformMatrix2BitBlockMap = transformMatrix2BitBlockMap = function(tfm) {
  var boxPoints, boxPointsT, cellsTransposition, i, tfmBitBlock, tfmCellIndex;
  boxPoints = [[-1, 0], [0, 0], [-1, -1], [0, -1]];
  boxPointsT = Cells.transform(boxPoints, tfm, false);
  tfmCellIndex = function(i) {
    return Cells.find(boxPoints, boxPointsT[i]);
  };
  cellsTransposition = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i <= 3; i = ++_i) {
      _results.push(tfmCellIndex(i));
    }
    return _results;
  })();
  tfmBitBlock = function(x) {
    var y, _i;
    y = 0;
    for (i = _i = 0; _i <= 3; i = ++_i) {
      if ((x >> i) & 1) {
        y = y | (1 << cellsTransposition[i]);
      }
    }
    return y;
  };
  return (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i <= 15; i = ++_i) {
      _results.push(tfmBitBlock(i));
    }
    return _results;
  })();
};

exports.evaluateCellList = evaluateCellList = function(rule, cells, phase) {
  var b_x, b_y, block, block2cells, key, transformed, x, x_code, y, y_code, _, _i, _len, _ref, _ref1, _ref2;
  if (rule[0] !== 0) {
    throw new Error("Rule has instable vacuum and not supported.");
  }
  block2cells = {};
  for (_i = 0, _len = cells.length; _i < _len; _i++) {
    _ref = cells[_i], x = _ref[0], y = _ref[1];
    x += phase;
    y += phase;
    b_x = x >> 1;
    b_y = y >> 1;
    key = "" + b_x + " " + b_y;
    block = (_ref1 = block2cells[key]) != null ? _ref1 : (block2cells[key] = [0, b_x, b_y]);
    block[0] |= 1 << ((x & 1) + (y & 1) * 2);
  }
  transformed = [];
  for (_ in block2cells) {
    _ref2 = block2cells[_], x_code = _ref2[0], b_x = _ref2[1], b_y = _ref2[2];
    b_x = (b_x << 1) - phase;
    b_y = (b_y << 1) - phase;
    y_code = rule[x_code];
    if (y_code & 1) {
      transformed.push([b_x, b_y]);
    }
    if (y_code & 2) {
      transformed.push([b_x + 1, b_y]);
    }
    if (y_code & 4) {
      transformed.push([b_x, b_y + 1]);
    }
    if (y_code & 8) {
      transformed.push([b_x + 1, b_y + 1]);
    }
  }
  return transformed;
};

extend_array = function(arr, arr1) {
  var x, _i, _len;
  for (_i = 0, _len = arr1.length; _i < _len; _i++) {
    x = arr1[_i];
    arr.push(x);
  }
  return arr;
};

exports.splitPattern = function(rule, pattern, steps) {
  var group2labels, grp, grp_key, i, iter, label, label2group, labelled_pattern, labels, merge_labels, number_of_groups, x, y, _i, _j, _len, _ref;
  label2group = {};
  group2labels = {};
  labelled_pattern = [];
  for (i = _i = 0, _len = pattern.length; _i < _len; i = ++_i) {
    _ref = pattern[i], x = _ref[0], y = _ref[1];
    label = i + 1;
    labelled_pattern.push([x, y, label]);
    label2group[label] = label;
    group2labels[label] = [label];
  }
  number_of_groups = pattern.length;
  merge_labels = function(lab1, lab2) {
    var grp1, grp1_labels, grp2, grp2_labels, _j, _len1;
    grp1 = label2group[lab1];
    grp2 = label2group[lab2];
    if (grp1 !== grp2) {
      grp1_labels = group2labels[grp1];
      grp2_labels = group2labels[grp2];
      if ((grp1_labels == null) || (grp2_labels == null)) {
        throw new Error("assertion: group has no labels");
      }
      extend_array(grp1_labels, grp2_labels);
      delete group2labels[grp2];
      for (_j = 0, _len1 = grp2_labels.length; _j < _len1; _j++) {
        label = grp2_labels[_j];
        label2group[label] = grp1;
      }
      number_of_groups -= 1;
    }
    return null;
  };
  for (iter = _j = 0; _j <= steps; iter = _j += 1) {
    labelled_pattern = evaluateLabelledCellList(rule, labelled_pattern, iter % 2, merge_labels);
    if (number_of_groups <= 1) {
      break;
    }
  }
  return (function() {
    var _results;
    _results = [];
    for (grp_key in group2labels) {
      labels = group2labels[grp_key];
      grp = parseInt(grp_key, 10);
      _results.push((function() {
        var _k, _len1, _results1;
        _results1 = [];
        for (_k = 0, _len1 = labels.length; _k < _len1; _k++) {
          label = labels[_k];
          _results1.push(pattern[parseInt(label, 10) - 1]);
        }
        return _results1;
      })());
    }
    return _results;
  })();
};

/*
//@ sourceMappingURL=cells.map
*/

},{"./math_util":6,"./reversible_ca":8,"./rle":9,"./rules":10}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var DomBuilder;

exports.DomBuilder = DomBuilder = (function() {
  function DomBuilder(tag) {
    var root;
    if (tag == null) {
      tag = null;
    }
    this.root = root = tag === null ? document.createDocumentFragment() : document.createElement(tag);
    this.current = this.root;
    this.vars = {};
  }

  DomBuilder.prototype.tag = function(name) {
    var e;
    this.current.appendChild(e = document.createElement(name));
    this.current = e;
    return this;
  };

  DomBuilder.prototype.store = function(varname) {
    this.vars[varname] = this.current;
    return this;
  };

  DomBuilder.prototype.rtag = function(var_name, name) {
    this.tag(name);
    return this.store(var_name);
  };

  DomBuilder.prototype.end = function() {
    var cur;
    this.current = cur = this.current.parentNode;
    if (cur === null) {
      throw new Error("Too many end()'s");
    }
    return this;
  };

  DomBuilder.prototype.text = function(txt) {
    this.current.appendChild(document.createTextNode(txt));
    return this;
  };

  DomBuilder.prototype.a = function(name, value) {
    this.current.setAttribute(name, value);
    return this;
  };

  DomBuilder.prototype.append = function(elementReference) {
    this.current.appendChild(elementReference);
    return this;
  };

  DomBuilder.prototype.DIV = function() {
    return this.tag("div");
  };

  DomBuilder.prototype.A = function() {
    return this.tag("a");
  };

  DomBuilder.prototype.SPAN = function() {
    return this.tag("span");
  };

  DomBuilder.prototype.ID = function(id) {
    return this.a("id", id);
  };

  DomBuilder.prototype.CLASS = function(cls) {
    return this.a("class", cls);
  };

  DomBuilder.prototype.finalize = function() {
    var r;
    r = this.root;
    this.root = this.current = this.vars = null;
    return r;
  };

  return DomBuilder;

})();

/*
//@ sourceMappingURL=dom_builder.map
*/

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Array2d, FieldView, MargolusNeighborehoodField, div, mod, _ref, _ref1;

_ref = require("./reversible_ca"), MargolusNeighborehoodField = _ref.MargolusNeighborehoodField, Array2d = _ref.Array2d;

_ref1 = require("./math_util"), div = _ref1.div, mod = _ref1.mod;

/*
Draw a block of field cells on a canvas
*/


exports.FieldView = FieldView = (function() {
  function FieldView(field) {
    this.field = field;
    this.cell_colors = ["#888", "#ff0"];
    this.cell_size = 4;
    this.grid_width = 1;
    this.old_field = null;
    this.grid_colors = ["rgb(153,153,153)", "gray"];
  }

  /*
  Return cell index from coordinates
  */


  FieldView.prototype.xy2index = function(x, y) {
    var cs;
    cs = this.cell_size;
    return [div(x, cs), div(y, cs)];
  };

  FieldView.prototype.draw_grid = function(context, x0, y0, x1, y1) {
    var drawGridHrz, drawGridVrt, size, spacing, xmax, xmin, ymax, ymin;
    size = this.cell_size;
    spacing = this.grid_width;
    if (size <= this.grid_width) {
      return;
    }
    xmax = size * x1;
    ymax = size * y1;
    xmin = size * x0;
    ymin = size * y0;
    drawGridVrt = function(xstart, style) {
      var x, _i, _ref2, _results;
      context.fillStyle = style;
      _results = [];
      for (x = _i = xstart, _ref2 = size * 2; _ref2 > 0 ? _i < xmax : _i > xmax; x = _i += _ref2) {
        _results.push(context.fillRect(x, ymin, spacing, ymax - ymin));
      }
      return _results;
    };
    drawGridHrz = function(ystart, style) {
      var y, _i, _ref2, _results;
      context.fillStyle = style;
      _results = [];
      for (y = _i = ystart, _ref2 = size * 2; _ref2 > 0 ? _i < ymax : _i > ymax; y = _i += _ref2) {
        _results.push(context.fillRect(xmin, y, xmax - xmin, spacing));
      }
      return _results;
    };
    drawGridHrz(ymin + size - 1, this.grid_colors[y0 % 2]);
    drawGridVrt(xmin + size - 1, this.grid_colors[x0 % 2]);
    drawGridHrz(ymin + size + size - 1, this.grid_colors[(y0 + 1) % 2]);
    return drawGridVrt(xmin + size + size - 1, this.grid_colors[(x0 + 1) % 2]);
  };

  FieldView.prototype.draw_box = function(context, x0, y0, x1, y1) {
    var data, i, idx, j, old_field, prev_state, size, spacing, state, _i, _j;
    size = this.cell_size;
    spacing = this.grid_width;
    data = this.field.data;
    old_field = this.get_old_field().data;
    prev_state = 255;
    for (i = _i = y0; _i < y1; i = _i += 1) {
      idx = this.field.cell_index(x0, i);
      for (j = _j = x0; _j < x1; j = _j += 1) {
        state = data[idx];
        if (old_field[idx] !== state) {
          if (state !== prev_state) {
            prev_state = state;
            context.fillStyle = this.cell_colors[state];
          }
          context.fillRect(size * j, size * i, size, size);
          old_field[idx] = state;
        }
        idx++;
      }
    }
    if (spacing > 0) {
      return this.draw_grid(context, x0, y0, x1, y1);
    }
  };

  FieldView.prototype.draw = function(context) {
    return this.draw_box(context, 0, 0, this.field.width, this.field.height);
  };

  FieldView.prototype.get_old_field = function() {
    var field, od;
    field = this.field;
    if (!this.old_field || this.old_field.width !== field.width || this.old_field.height !== field.height) {
      od = new Array2d(field.width, field.height);
      od.fill(255);
      this.old_field = od;
      return od;
    } else {
      return this.old_field;
    }
  };

  FieldView.prototype.draw_cell = function(context, x, y, size, state) {
    context.fillStyle = this.cell_colors[state];
    return context.fillRect(x, y, size, size);
  };

  FieldView.prototype.invalidate = function() {
    if (this.old_field) {
      return this.old_field.fill(255);
    }
  };

  return FieldView;

})();

/*
//@ sourceMappingURL=field_view.map
*/

},{"./math_util":6,"./reversible_ca":8}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Maximizer, gcd, isign, line_pixels, mod, rational2str, scale_array_inplace;

exports.getReadableFileSizeString = function(fileSizeInBytes) {
  var byteUnits, i;
  i = -1;
  byteUnits = [" kB", " MB", " GB", " TB", "PB", "EB", "ZB", "YB"];
  while (true) {
    fileSizeInBytes = fileSizeInBytes / 1024;
    i++;
    if (!(fileSizeInBytes > 1024)) {
      break;
    }
  }
  return "" + Math.max(fileSizeInBytes, 0.1).toFixed(1) + byteUnits[i];
};

exports.rational2str = rational2str = function(num, den) {
  var d;
  if (den < 0) {
    return rational2str(-num, -den);
  }
  if (num === 0) {
    if (den === 0) {
      return "0/0";
    } else {
      return "0";
    }
  } else {
    if (den === 0) {
      return "1/0";
    } else {
      d = gcd(Math.abs(num), den);
      return "" + (num / d) + "/" + (den / d);
    }
  }
};

/*
Mathematical modulo (works with negative values)
*/


exports.mod = mod = function(x, y) {
  var m;
  m = x % y;
  if (m < 0) {
    return m + y;
  } else {
    return m;
  }
};

/*
Integer division
*/


exports.div = function(x, y) {
  return (x / y) | 0;
};

exports.isign = isign = function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};

/*
Fill 0-based array with constant value
*/


exports.fill_array = function(arr, n, x) {
  var i, _i;
  for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
    arr[i] = x;
  }
  return arr;
};

scale_array_inplace = function(arr, k) {
  var i, _i, _ref;
  for (i = _i = 0, _ref = arr.length; _i < _ref; i = _i += 1) {
    arr[i] *= k;
  }
  return arr;
};

/*
Primitive line drawing algorithm
*/


exports.line_pixels = line_pixels = function(dx, dy) {
  var k, sx, sy, x, xx, yy, _i, _ref, _ref1;
  sx = isign(dx);
  sy = isign(dy);
  if (sx < 0 || sy < 0) {
    _ref = line_pixels(dx * sx, dy * sy), xx = _ref[0], yy = _ref[1];
    if (sx !== 1) {
      scale_array_inplace(xx, sx);
    }
    if (sy !== 1) {
      scale_array_inplace(yy, sy);
    }
    return [xx, yy];
  }
  if (dy > dx) {
    _ref1 = line_pixels(dy, dx), xx = _ref1[0], yy = _ref1[1];
    return [yy, xx];
  }
  if (dx === 0) {
    return [[0], [0]];
  }
  xx = [];
  yy = [];
  k = dy / dx;
  for (x = _i = 0; 0 <= dx ? _i <= dx : _i >= dx; x = 0 <= dx ? ++_i : --_i) {
    xx.push(x);
    yy.push(Math.floor(x * k));
  }
  return [xx, yy];
};

exports.gcd = gcd = function(a, b) {
  if (a < b) {
    return gcd(b, a);
  } else if (b === 0) {
    return a;
  } else {
    return gcd(b, a % b);
  }
};

exports.cap = function(a, b, x) {
  return Math.min(b, Math.max(a, x));
};

exports.Maximizer = Maximizer = (function() {
  function Maximizer(targetFunc) {
    this.targetFunc = targetFunc != null ? targetFunc : function(x) {
      return x;
    };
    this.bestX = null;
    this.bestY = null;
  }

  Maximizer.prototype.put = function(x) {
    var y;
    y = this.targetFunc(x);
    if (!this.hasAny() || (y > this.bestY)) {
      this.bestX = x;
      this.bestY = y;
    }
    return this;
  };

  Maximizer.prototype.putAll = function(xs) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      this.put(x);
    }
    return null;
  };

  Maximizer.prototype.hasAny = function() {
    return this.bestY != null;
  };

  Maximizer.prototype.getArg = function() {
    if (!this.hasAny()) {
      throw new Error("Has no values");
    }
    return this.bestX;
  };

  Maximizer.prototype.getVal = function() {
    if (!this.hasAny()) {
      throw new Error("Has no values");
    }
    return this.bestY;
  };

  return Maximizer;

})();

/*
//@ sourceMappingURL=math_util.map
*/

},{}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var parseUri;

exports.parseUri = parseUri = function(str) {
  var i, m, o, uri;
  o = parseUri.options;
  m = o.parser[(o.strictMode ? "strict" : "loose")].exec(str);
  uri = {};
  i = 14;
  while (i--) {
    uri[o.key[i]] = m[i] || "";
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
    if ($1) {
      return uri[o.q.name][$1] = $2;
    }
  });
  return uri;
};

parseUri.options = {
  strictMode: false,
  key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
  q: {
    name: "queryKey",
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};

/*
//@ sourceMappingURL=parseuri.map
*/

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Array2d, MargolusNeighborehoodField, Rules, div, math_util, mod, module_rules;

math_util = require("./math_util");

module_rules = require("./rules");

div = math_util.div, mod = math_util.mod;

Rules = module_rules.Rules;

/*
A 2-dimensional array of bytes!, with row-first organization
*/


exports.Array2d = Array2d = (function() {
  function Array2d(width, height) {
    var e;
    this.width = width;
    this.height = height;
    this.num_cells = this.width * this.height;
    this.data = (function() {
      try {
        return new Int8Array(this.num_cells);
      } catch (_error) {
        e = _error;
        return [];
      }
    }).call(this);
  }

  Array2d.prototype.fill = function(v) {
    return math_util.fill_array(this.data, this.num_cells, v);
  };

  Array2d.prototype.cell_index = function(x, y) {
    return y * this.width + x;
  };

  Array2d.prototype.set = function(x, y, v) {
    return this.data[this.cell_index(x, y)] = v;
  };

  Array2d.prototype.set_wrapped = function(x, y, v) {
    return this.data[this.cell_index(mod(x, this.width), mod(y, this.height))] = v;
  };

  Array2d.prototype.get = function(x, y) {
    return this.data[this.cell_index(x, y)];
  };

  Array2d.prototype.toggle = function(x, y) {
    return this.data[this.cell_index(x, y)] ^= 1;
  };

  Array2d.prototype.size = function() {
    return [this.width, this.height];
  };

  Array2d.prototype.get_wrapped = function(x, y) {
    return this.data[this.cell_index(mod(x, this.width), mod(y, this.height))];
  };

  /*
  #Random fill block with given percentage
  */


  Array2d.prototype.random_fill = function(x0, y0, x1, y1, percent) {
    var data, i, x, y, _i, _j;
    data = this.data;
    for (y = _i = y0; _i < y1; y = _i += 1) {
      i = this.cell_index(x0, y);
      for (x = _j = x0; _j < x1; x = _j += 1) {
        data[i] = (Math.random() <= percent ? 1 : 0);
        i++;
      }
    }
    return null;
  };

  Array2d.prototype.fill_box = function(x0, y0, x1, y1, value) {
    var data, i, x, y, _i, _j;
    data = this.data;
    for (y = _i = y0; _i < y1; y = _i += 1) {
      i = this.cell_index(x0, y);
      for (x = _j = x0; _j < x1; x = _j += 1) {
        data[i] = value;
        i++;
      }
    }
    return null;
  };

  Array2d.prototype.fill_outside_box = function(x0, y0, x1, y1, value) {
    var h, w;
    w = this.width;
    h = this.height;
    this.fill_box(0, 0, w, y0);
    this.fill_box(0, y0, x0, y1);
    this.fill_box(x1, y0, w, y1);
    return this.fill_box(0, y1, w, h);
  };

  /*
  Find minimal bounding box for the given block of the field
  */


  Array2d.prototype.bounding_box = function(x0, y0, x1, y1) {
    var x, xmax, xmin, y, ymax, ymin, _i, _j;
    xmin = x1 - 1;
    ymin = y1 - 1;
    xmax = x0;
    ymax = y0;
    for (y = _i = y0; _i < y1; y = _i += 1) {
      for (x = _j = x0; _j < x1; x = _j += 1) {
        if (this.get(x, y) !== 0) {
          xmin = Math.min(xmin, x);
          xmax = Math.max(xmax, x);
          ymin = Math.min(ymin, y);
          ymax = Math.max(ymax, y);
        }
      }
    }
    if (xmax < xmin || ymax < ymin) {
      return [x0, y0, x0, y0];
    } else {
      return [xmin, ymin, xmax + 1, ymax + 1];
    }
  };

  Array2d.prototype.is_nonempty = function(x0, y0, x1, y1) {
    var x, y, _i, _j;
    for (y = _i = y0; _i < y1; y = _i += 1) {
      for (x = _j = x0; _j < x1; x = _j += 1) {
        if (this.get(x, y) !== 0) {
          return true;
        }
      }
    }
    return false;
  };

  /*
  return list of coordinates of active cells. Coordinates are relativeto the origin of the box
  */


  Array2d.prototype.get_cells = function(x0, y0, x1, y1) {
    var rval, x, y, _i, _j;
    rval = [];
    for (y = _i = y0; _i < y1; y = _i += 1) {
      for (x = _j = x0; _j < x1; x = _j += 1) {
        if (this.get_wrapped(x, y) !== 0) {
          rval.push([x - x0, y - y0]);
        }
      }
    }
    return rval;
  };

  /*
  Put list of cells to the field
  */


  Array2d.prototype.put_cells = function(lst, x, y, value) {
    var h, w, xx, yy, _i, _len, _ref;
    if (value == null) {
      value = 1;
    }
    w = this.width;
    h = this.height;
    for (_i = 0, _len = lst.length; _i < _len; _i++) {
      _ref = lst[_i], xx = _ref[0], yy = _ref[1];
      this.set(mod(x + xx, w), mod(y + yy, h), value);
    }
    return null;
  };

  Array2d.prototype.pick_pattern_at = function(x, y, x0, y0, erase, range) {
    var cells, do_pick_at, h, is_visited, key, self, visit, visited, w;
    if (erase == null) {
      erase = false;
    }
    if (range == null) {
      range = 4;
    }
    self = this;
    w = this.width;
    h = this.height;
    visited = {};
    cells = [];
    key = function(x, y) {
      return "" + x + "#" + y;
    };
    is_visited = function(x, y) {
      return visited.hasOwnProperty(key(x, y));
    };
    visit = function(x, y) {
      return visited[key(x, y)] = true;
    };
    do_pick_at = function(x, y) {
      var dx, dy, wx, wy, y1, _i, _j;
      wx = mod(x, w);
      wy = mod(y, h);
      if (is_visited(wx, wy) || self.get(wx, wy) === 0) {
        return;
      }
      visit(wx, wy);
      cells.push([x - x0, y - y0]);
      if (erase) {
        self.set(wx, wy, 0);
      }
      for (dy = _i = -range; _i <= range; dy = _i += 1) {
        y1 = y + dy;
        for (dx = _j = -range; _j <= range; dx = _j += 1) {
          if (dy === 0 && dx === 0) {
            continue;
          }
          do_pick_at(x + dx, y1);
        }
      }
      return cells;
    };
    return do_pick_at(x, y);
  };

  return Array2d;

})();

/*
A field with Margolus neighborehood
*/


exports.MargolusNeighborehoodField = MargolusNeighborehoodField = (function() {
  function MargolusNeighborehoodField(field, rule) {
    this.field = field;
    if (field.width % 2 !== 0 || field.height % 2 !== 0) {
      throw "Field size must be even, not " + field.width + "x" + field.height;
    }
    this.generation = 0;
    this.phase = 0;
    this.set_rule(rule);
  }

  MargolusNeighborehoodField.prototype.set_rule = function(rule) {
    this.rule = rule;
    return this.inverse_rule = null;
  };

  MargolusNeighborehoodField.prototype.transform_from = function(x0, y0, rule) {
    if (rule.call != null) {
      return this.transform_from_general(x0, y0, rule);
    } else {
      return this.transform_from_2state(x0, y0, rule);
    }
  };

  MargolusNeighborehoodField.prototype.transform_from_2state = function(x0, y0, rule) {
    var X, Y, a, b, c, d, data, dx, dy, field, h, w, x, y, _i, _j;
    field = this.field;
    data = field.data;
    w = field.width;
    h = field.height;
    a = 0;
    for (y = _i = y0; _i < h; y = _i += 2) {
      dy = (y + 1 < h ? w : w * (1 - h));
      a = y * w + x0;
      for (x = _j = x0; _j < w; x = _j += 2) {
        dx = (x + 1 < w ? 1 : 1 - w);
        b = a + dx;
        c = a + dy;
        d = b + dy;
        X = data[a] | (data[b] << 1) | (data[c] << 2) | (data[d] << 3);
        Y = rule[X];
        if (Y !== X) {
          data[a] = Y & 1;
          data[b] = (Y >> 1) & 1;
          data[c] = (Y >> 2) & 1;
          data[d] = (Y >> 3) & 1;
        }
        a += 2;
      }
    }
    return null;
  };

  MargolusNeighborehoodField.prototype.transform_from_general = function(x0, y0, general_rule) {
    var a, b, c, d, data, dx, dy, field, h, w, x, y, _i, _j;
    field = this.field;
    data = field.data;
    w = field.width;
    h = field.height;
    a = 0;
    for (y = _i = y0; _i < h; y = _i += 2) {
      dy = (y + 1 < h ? w : w * (1 - h));
      a = y * w + x0;
      for (x = _j = x0; _j < w; x = _j += 2) {
        dx = (x + 1 < w ? 1 : 1 - w);
        b = a + dx;
        c = a + dy;
        d = b + dy;
        general_rule(data, a, b, c, d);
        a += 2;
      }
    }
    return null;
  };

  MargolusNeighborehoodField.prototype.transform = function() {
    var xy0;
    xy0 = this.phase;
    this.transform_from(xy0, xy0, this.rule);
    this.phase = mod(this.phase + 1, 2);
    return this.generation++;
  };

  MargolusNeighborehoodField.prototype.untransform = function() {
    var xy0;
    xy0 = mod(this.phase - 1, 2);
    this.transform_from(xy0, xy0, this.get_inverse_rule());
    this.phase = mod(this.phase - 1, 2);
    return this.generation--;
  };

  /*
  Calculates reverse rule and returns it.
  Raises an exception, if rule is not reversible
  */


  MargolusNeighborehoodField.prototype.get_inverse_rule = function() {
    var ir;
    if ((ir = this.inverse_rule) != null) {
      return ir;
    } else {
      return this.inverse_rule = (function() {
        if (this.rule.call != null) {
          if (this.rule.inverse == null) {
            throw "Inverse rule not provided!";
          }
          return this.rule.inverse;
        } else {
          return Rules.reverse(this.rule);
        }
      }).call(this);
    }
  };

  MargolusNeighborehoodField.prototype.clear = function() {
    this.set_generation(0);
    return this.field.fill(0);
  };

  MargolusNeighborehoodField.prototype.set_generation = function(g) {
    this.phase = mod(g, 2);
    return this.generation = g;
  };

  MargolusNeighborehoodField.prototype.snap_below = function(x) {
    return x - mod(x + this.phase, 2);
  };

  MargolusNeighborehoodField.prototype.snap_upper = function(x) {
    return x + mod(x + this.phase, 2);
  };

  MargolusNeighborehoodField.prototype.snap_box = function(_arg) {
    var x0, x1, y0, y1;
    x0 = _arg[0], y0 = _arg[1], x1 = _arg[2], y1 = _arg[3];
    return [this.snap_below(x0), this.snap_below(y0), this.snap_upper(x1), this.snap_upper(y1)];
  };

  return MargolusNeighborehoodField;

})();

/*
//@ sourceMappingURL=reversible_ca.map
*/

},{"./math_util":6,"./rules":10}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
Library for RLE ensocing and decoding, used by Life programs
*/

/*
Encoder, creating RLE string from cell data
*/

var RLEEncoder, remove_whitespaces;

RLEEncoder = (function() {
  function RLEEncoder() {
    this.stack = [];
    this.cur_item = null;
  }

  RLEEncoder.prototype.get_cur_char = function() {
    var ci;
    ci = this.cur_item;
    if (ci == null) {
      return null;
    } else {
      return ci[0];
    }
  };

  RLEEncoder.prototype.put_cell = function(value) {
    return this.put((value ? "o" : "b"));
  };

  RLEEncoder.prototype.newline = function() {
    return this.put("$");
  };

  RLEEncoder.prototype.put = function(c) {
    var cur_char;
    if (c !== "b" && c !== "o" && c !== "$") {
      throw "Character " + c + " is wrong";
    }
    cur_char = this.get_cur_char();
    if (c === cur_char) {
      return this.cur_item[1] += 1;
    } else {
      if (c === "$" && cur_char === "b") {
        this.pop();
        return this.put(c);
      } else {
        this.cur_item = [c, 1];
        return this.stack.push(this.cur_item);
      }
    }
  };

  RLEEncoder.prototype.pop = function() {
    var stk;
    stk = this.stack;
    stk.pop();
    if (stk.length === 0) {
      return this.cur_item = null;
    } else {
      return this.cur_item = stk[stk.length - 1];
    }
  };

  RLEEncoder.prototype.trim_zeros = function() {
    var c, len, stk, _results;
    stk = this.stack;
    _results = [];
    while (true) {
      len = stk.length;
      if (len > 0) {
        c = stk[len - 1][0];
        if (c === "$" || c === "b") {
          stk.pop();
          continue;
        }
      }
      break;
    }
    return _results;
  };

  RLEEncoder.prototype.get_rle = function() {
    var c, cnt, output, _i, _len, _ref, _ref1;
    this.trim_zeros();
    output = "";
    _ref = this.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], c = _ref1[0], cnt = _ref1[1];
      if (cnt > 1) {
        output += cnt;
      }
      output += c;
    }
    return output;
  };

  return RLEEncoder;

})();

/*
Parse Life RLE string, producing 2 arrays: Xs and Ys.
*/


exports.parse_rle = function(rle_string, put_cell) {
  var c, count, curCount, i, j, x, y, _i, _j, _ref;
  x = 0;
  y = 0;
  curCount = 0;
  for (i = _i = 0, _ref = rle_string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    c = rle_string.charAt(i);
    if (("0" <= c && c <= "9")) {
      curCount = curCount * 10 + parseInt(c, 10);
    } else {
      count = Math.max(curCount, 1);
      curCount = 0;
      switch (c) {
        case "b":
          x += count;
          break;
        case "$":
          y += count;
          x = 0;
          break;
        case "o":
          for (j = _j = 0; _j < count; j = _j += 1) {
            put_cell(x, y);
            x += 1;
          }
          break;
        default:
          throw new Error("Unexpected character '" + c + "' at position " + i);
      }
    }
  }
  return null;
};

exports.remove_whitespaces = remove_whitespaces = function(s) {
  return s.replace(/\s+/g, "");
};

/*
//@ sourceMappingURL=rle.map
*/

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Bits, NamedRules, Rules, compose_transpositions;

compose_transpositions = function(t1, t2) {
  var n, t1_i;
  if ((n = t1.length) !== t2.length) {
    throw new Error("Transpositions are incompatible");
  }
  return (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = t1.length; _i < _len; _i++) {
      t1_i = t1[_i];
      _results.push(t2[t1_i]);
    }
    return _results;
  })();
};

exports.Rules = Rules = {
  /*
  # Create rule object from list
  */

  from_list: typeof Int8Array !== "undefined" && Int8Array !== null ? function(rule_list) {
    return new Int8Array(rule_list);
  } : function(rule_list) {
    return rule_list;
  },
  to_list: typeof Int8Array !== "undefined" && Int8Array !== null ? function(tarr) {
    var ti, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = tarr.length; _i < _len; _i++) {
      ti = tarr[_i];
      _results.push(ti);
    }
    return _results;
  } : function(rule) {
    return rule;
  },
  /*
  # Parse string rule
  */

  parse: function(rule_str, separator) {
    var i, nparts, parts, ri, riStr, rule, _i, _len;
    if (separator == null) {
      separator = ",";
    }
    parts = rule_str.split(separator);
    nparts = parts.length;
    if (nparts !== 16) {
      throw new Error("Invalid rule string [" + rule_str + "], rule must have 16 parts, but have " + nparts);
    }
    rule = [];
    for (i = _i = 0, _len = parts.length; _i < _len; i = ++_i) {
      riStr = parts[i];
      rule.push(ri = parseInt(riStr, 10));
      if (!((0 <= ri && ri < 16))) {
        throw "Invalid value [" + ri + "] at position " + i + " in rule; must have values in range 0..15";
      }
    }
    return Rules.from_list(rule);
  },
  stringify: function(rule) {
    return Rules.to_list(rule).join(",");
  },
  equals: function(r1, r2) {
    var i, r1i, _i, _len;
    for (i = _i = 0, _len = r1.length; _i < _len; i = ++_i) {
      r1i = r1[i];
      if (r1i !== r2[i]) {
        return false;
      }
    }
    return true;
  },
  /*
  # Inverse rule, raise exception if impossible
  */

  reverse: function(rule) {
    var i, rrule, _i;
    if (!Rules.is_invertible(rule)) {
      throw new Error("Rule is not invertible");
    }
    rrule = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 15; i = ++_i) {
        _results.push(null);
      }
      return _results;
    })();
    for (i = _i = 0; _i <= 15; i = ++_i) {
      rrule[rule[i]] = i;
    }
    return Rules.from_list(rrule);
  },
  /*
  # Checks whether the rule is invertible
  */

  is_invertible: function(rule) {
    var a, a0, all_transforms, b, b0, i, r, ri, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    r = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = rule.length; _i < _len; _i++) {
        ri = rule[_i];
        _results.push(ri);
      }
      return _results;
    })();
    r.sort(function(a, b) {
      return a - b;
    });
    for (i = _i = 0, _len = r.length; _i < _len; i = ++_i) {
      ri = r[i];
      if (ri !== i) {
        return false;
      }
    }
    true;
    ({
      make_from_samples: function(samples, invariants) {}
    });
    all_transforms = function(x, y, transforms) {
      var walk, x2y, xy_pairs;
      x2y = (function() {
        var _j, _results;
        _results = [];
        for (i = _j = 0; _j <= 15; i = ++_j) {
          _results.push(null);
        }
        return _results;
      })();
      xy_pairs = [];
      walk = function(x, y) {
        var tfm, y_old, _j, _len1;
        if ((y_old = x2y[x]) != null) {
          if (y_old !== y) {
            throw new Error("Samples are contradicting invariants");
          }
        } else {
          x2y[x] = y;
          xy_pairs.push([x, y]);
          for (_j = 0, _len1 = transforms.length; _j < _len1; _j++) {
            tfm = transforms[_j];
            walk(tfm(x), tfm(y));
          }
        }
        return null;
      };
      walk(x, y);
      return xy_pairs;
    };
    rule = (function() {
      var _j, _results;
      _results = [];
      for (i = _j = 0; _j <= 15; i = ++_j) {
        _results.push(null);
      }
      return _results;
    })();
    for (i = _j = 0, _len1 = samples.length; _j < _len1; i = ++_j) {
      _ref = samples[i], a0 = _ref[0], b0 = _ref[1];
      _ref1 = all_transforms(a, b, invariants);
      for (b = _k = 0, _len2 = _ref1.length; _k < _len2; b = ++_k) {
        a = _ref1[b];
        if (rule[a] !== null && rule[a] !== b) {
          throw new Error("Sample " + (i + 1) + " conflicts with other samples");
        }
        rule[a] = b;
      }
    }
    for (i = _l = 0, _len3 = rule.length; _l < _len3; i = ++_l) {
      ri = rule[i];
      if (ri === null) {
        throw new Error("Samples incomplete. State " + i + " has no descendant");
      }
    }
    return Rules.from_list(rule);
  },
  /*
  #Take samples, pairs ( (a,b)... ) and builds rotation-invariant function,
  #that supports this transformation
  */

  make_rot_invariant_rule_from_samples: function(samples) {
    var a, b, i, r, ri, rule, _i, _j, _k, _len, _len1, _ref;
    rule = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 15; i = ++_i) {
        _results.push(null);
      }
      return _results;
    })();
    for (i = _i = 0, _len = samples.length; _i < _len; i = ++_i) {
      _ref = samples[i], a = _ref[0], b = _ref[1];
      for (r = _j = 0; _j <= 3; r = ++_j) {
        if (rule[a] !== null && rule[a] !== b) {
          throw new Error("Sample #" + (i + 1) + " (rotated by" + r + ") conflicts");
        }
        rule[a] = b;
        a = Bits.rotate(a);
        b = Bits.rotate(b);
      }
    }
    for (i = _k = 0, _len1 = rule.length; _k < _len1; i = ++_k) {
      ri = rule[i];
      if (ri === null) {
        throw new Error("Samples incomplete. State " + i + " has no descendant");
      }
    }
    return Rules.from_list(rule);
  },
  /*
  (rule::Rule, transform::Int->Int).
  Checks, if  Rule*Transform == Transofmr*Rule
  */

  is_transposable_with: function(rule, transform) {
    var x, x_f_t, x_t_f, _i;
    for (x = _i = 0; _i < 16; x = ++_i) {
      x_t_f = rule[transform(x)];
      x_f_t = transform(rule[x]);
      if (x_t_f !== x_f_t) {
        return false;
      }
    }
    return true;
  },
  find_symmetries: function(rule) {
    var fliph_negate, flipv_negate, name, symmetries, transform, transforms, _i, _len, _ref;
    fliph_negate = function(x) {
      return Bits.negate(Bits.flip_h(x));
    };
    flipv_negate = function(x) {
      return Bits.negate(Bits.flip_v(x));
    };
    transforms = [["rot90", Bits.rotate], ["rot180", Bits.rotate180], ["flipx", Bits.flip_h], ["flipy", Bits.flip_v], ["negate", Bits.negate], ["flipy_neg", flipv_negate], ["flipx_neg", fliph_negate]];
    symmetries = {};
    for (_i = 0, _len = transforms.length; _i < _len; _i++) {
      _ref = transforms[_i], name = _ref[0], transform = _ref[1];
      if (Rules.is_transposable_with(rule, transform)) {
        symmetries[name] = true;
      }
    }
    return symmetries;
  },
  /*
  #Rules can be:
  #- Stable: population never changes
  #- Inverse-stable: population inverts on every step
  #- None: population changes.
  */

  invariance_type: function(rule) {
    var pop_invstable, pop_stable, sx, sy, x, _i;
    pop_stable = true;
    pop_invstable = true;
    for (x = _i = 0; _i < 16; x = ++_i) {
      sx = Bits.sum(x);
      sy = Bits.sum(rule[x]);
      if (sx !== sy) {
        pop_stable = false;
      }
      if (sx !== 4 - sy) {
        pop_invstable = false;
      }
      if (!pop_stable && !pop_invstable) {
        break;
      }
    }
    if (pop_stable) {
      return "const";
    }
    if (pop_invstable) {
      return "inv-const";
    }
    return "none";
  },
  vacuum_period: function(rule) {
    var mirror_bits, period, x, _i;
    mirror_bits = Bits.rotate180;
    x = 0;
    for (period = _i = 1; _i <= 16; period = ++_i) {
      if ((x = mirror_bits(rule[x])) === 0) {
        return period;
      }
    }
    return null;
  },
  flashing_to_regular: function(rule) {
    var transp_inv;
    if (!Rules.is_flashing(rule)) {
      throw new Error("Rule is not flashing");
    }
    transp_inv = Bits.tabulate(Bits.invert);
    return [compose_transpositions(rule, transp_inv), compose_transpositions(transp_inv, rule)];
  },
  is_flashing: function(rule) {
    return rule[0] === 15;
  },
  is_vacuum_stable: function(rule) {
    return rule[0] === 0;
  }
};

exports.Bits = Bits = {
  rotate: function(x) {
    var a, b, c, d, _ref;
    _ref = Bits.get(x), a = _ref[0], b = _ref[1], c = _ref[2], d = _ref[3];
    return Bits.fromBits(b, d, a, c);
  },
  get: function(x) {
    var i, _i, _results;
    _results = [];
    for (i = _i = 0; _i <= 3; i = ++_i) {
      _results.push((x >> i) & 1);
    }
    return _results;
  },
  fromBits: function(a, b, c, d) {
    return a | (b << 1) | (c << 2) | (d << 3);
  },
  rotate180: function(x) {
    var a, b, c, d, _ref;
    _ref = Bits.get(x), a = _ref[0], b = _ref[1], c = _ref[2], d = _ref[3];
    return Bits.fromBits(d, c, b, a);
  },
  flip_h: function(x) {
    var a, b, c, d, _ref;
    _ref = Bits.get(x), a = _ref[0], b = _ref[1], c = _ref[2], d = _ref[3];
    return Bits.fromBits(b, a, d, c);
  },
  flip_v: function(x) {
    var a, b, c, d, _ref;
    _ref = Bits.get(x), a = _ref[0], b = _ref[1], c = _ref[2], d = _ref[3];
    return Bits.fromBits(c, d, a, b);
  },
  negate: function(x) {
    return 15 - x;
  },
  sum: function(x) {
    var a, b, c, d, _ref;
    _ref = Bits.get(x), a = _ref[0], b = _ref[1], c = _ref[2], d = _ref[3];
    return a + b + c + d;
  },
  tabulate: function(func) {
    var i, _i, _results;
    _results = [];
    for (i = _i = 0; _i <= 15; i = ++_i) {
      _results.push(func(i));
    }
    return _results;
  }
};

exports.NamedRules = NamedRules = {
  tron: Rules.parse("15,1,2,3,4,5,6,7,8,9,10,11,12,13,14,0", ","),
  billiardBallMachine: Rules.parse("0,8,4,3,2,5,9,7,1,6,10,11,12,13,14,15"),
  bounceGas: Rules.parse("0,8,4,3,2,5,9,14, 1,6,10,13,12,11,7,15"),
  hppGas: Rules.parse("0,8,4,12,2,10,9, 14,1,6,5,13,3,11,7,15"),
  rotations: Rules.parse("0,2,8,12,1,10,9, 11,4,6,5,14,3,7,13,15"),
  rotations2: Rules.parse("0,2,8,12,1,10,9, 13,4,6,5,7,3,14,11,15"),
  rotations3: Rules.parse("0,4,1,10,8,3,9,11, 2,6,12,14,5,7,13,15"),
  rotations4: Rules.parse("0,4,1,12,8,10,6,14, 2,9,5,13,3,11,7,15"),
  sand: Rules.parse("0,4,8,12,4,12,12,13, 8,12,12,14,12,13,14,15"),
  stringThing: Rules.parse("0,1,2,12,4,10,9,7,8, 6,5,11,3,13,14,15", ","),
  stringThing2: Rules.parse("0,1,2,12,4,10,6,7,8, 9,5,11,3,13,14,15"),
  swapOnDiag: Rules.parse("0,8,4,12,2,10,6,14, 1,9,5,13,3,11,7,15"),
  critters: Rules.make_rot_invariant_rule_from_samples([[0, 15], [15, 0], [1, 14], [14, 8], [3, 3], [6, 6]]),
  doubleRotate: Rules.parse("0, 2, 8, 3, 1, 5, 6, 13, 4, 9, 10, 7, 12, 14, 11, 15"),
  singleRotate: Rules.make_rot_invariant_rule_from_samples([[0, 0], [1, 2], [3, 3], [6, 6], [7, 7], [15, 15]])
};

exports.Rule2Name = (function() {
  var name, r2n, rule;
  r2n = {};
  for (name in NamedRules) {
    rule = NamedRules[name];
    r2n[Rules.stringify(rule)] = name;
  }
  return r2n;
})();

/*
//@ sourceMappingURL=rules.map
*/

},{}]},{},[1])
;